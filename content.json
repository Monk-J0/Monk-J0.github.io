{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"Linux系统笔记","date":"2019-06-20T07:03:49.581Z","updated":"2019-06-12T04:06:15.242Z","comments":true,"path":"2019/06/20/Linux系统笔记/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux系统笔记/","excerpt":"","text":"Day01:** 0dir1.文件类型:普通文件,目录文件,管道文件,连接文件,设备文件 02.linux常用命令 命令 作用 快捷操作 备注 man 帮助文档—————————————————————- 空格:手册下一页||Enter:下一行||b:后一屏幕||f:前一屏幕||q:退出||/word:搜索word||h:;列出功能键 man手册由9章:标准命令,系统函数,库函数,设备文件说明,文件格式,游戏,杂项,管理员命令 help 帮助文档 –help 帮助文档 pwd 显示当前目录 cd 切换目录 ls 展示当前目录文件 *:通配符.可以表示任何字符.?:通配符,可以表示任意一个字符. mkdir 创建目录 rmdir 删除目录 只能删除空目录 cp 拷贝 mv 裁剪和重命名 touch 创建文件 rm 删除文件 可以递归删除目录 cat 查看文件内容 more 管道文件,分页显示内容 不能回退 less 管道文件,分页显示内容 可以回退 head 从头部开始查看前n行内容 head -n[行数] 文件名 tail 从尾部开始查看最后n行内容 tail -n[行数] 文件名 du 查看目录或文件大小 文件实际占用内存和文件大小不相同.受到系统磁盘格式影响 df 查看磁盘空余空间大小 find 查找 find 路径 -size 范围(+大于 -小于)//find -type “文件类型” file 查看文件类型 grep 文本中的查找 grep [选项] “关键字” 路径 一般配合管道文件使用 histroy 查询历史输入命令 tar 解压或压缩文件||打包或解包 tar -cvf 归档包.tar 要压缩的文件名…(打包)||tar -xvf 归档包.tar -C 路径(解包)||(一步压缩)tar -zcvf 文件名.tar.gz 要压缩的文件||(一步解压)tar -zxvf 压缩包.tar.gz -C 路径 推荐使用一部解压和一步压缩 gzip 解压或压缩文件 gzip -r 归档文件.tar(压缩)||gzip -d 压缩文件.gz(解压) 需要先归档,才能压缩 bzip2 解压或压缩文件 tar -jcvf 要所报.tar.bz2(一步压缩)||tar -jzvf 压缩包.tar.bz2 -C 路径(一步解压) 效率不如gzip zip/unzip 解压或压缩文件 zip -r 压缩包名 文件…(压缩)||unzip -d 解压路径 压缩包.zip 压缩效率很差.压缩好之后自动加上.zip后缀. chmod 修改用户权限(字母发) chmod (u/g/o/a)组名(+/-/=)修改方式 (r/w/x)权限类型,可多选 文件名 || chmod g-rw file删除组员对于文件file的访问和写入权限 修改用户权限(数字法) chmod 数字(八进制) 文件名 chmod 777 file添加所有成员对于file的读写执行权限.777 – 111 111 111每三位对应rwx 修改目录下所有文件和子目录的权限 chmod -R 数字(八进制) 目录名 修改文件夹下的所有文件和子目录的权限 chown 修改文件所有者 chown 用户名 文件名 chgrp 修改文件的所属组 chgrp 用户组名 文件名 su 切换用户 su 用户名 su - 用户名 会切换到用户的家目录|| su 用户名 则不会切换到家目录 whoami 查看当前用户 who 查看登录到服务器的用户 exit 退出当前用户 根据切换用户路径一步一步退出 last 查看登录记录 ps 查看进程 ps -aux 查看所有进程信息 || ps -a 查看该终端所有进程 ||ps -x 查看不在该终端的所有内容 ||ps -Lf 进程号 查看一个进程中的线程 [a/u/x/w/r] kill 给进程发送信号(一般用于杀死进程) kill -9 进程编号 -l(查询信号编号) 实质:给pid进程号的进程发送9号信号,接到9号信号,进程会被杀死 killall 根据进程名字杀死进程 apt-get ubuntu在线安装软件 /etc/apt/sources.list存储了更新源,可以修改 dpkg ubuntu离线安装包安装 dpkg deb文件 yum centos在线安装软件 &gt; 重定向(覆盖) ls &gt; 1.txt //将ls的内容输出到1.txt中 重定向时将原本输出到屏幕上的内容输入到文件中 重定向(合并) cat 1.txt 2.txt &gt; 3.txt //将1.txt和2.txtx中的内容输入到3.txt中 &gt;&gt; 重定向(追加) ls &gt;&gt; 1.txt //将ls的内容追加到1.txt中 tree 树状结构显示目录 tree -L 层数 目录 //按照指定层数显示目录 ln 创建硬连接 ln 源文件 [目标路径] //本质时创建了一个和源文件绑定的文件 硬连接修改的内容会同步到其他连接的文件中.但删除任一硬连接文件和源文件不会影响其他文件 ln -s 创建软连接 ln -s 源文件 [目标路径] 软链接等效于windows中的快捷方式.连接文件内容的修改会同步到对应文件中.删除连接文件不影响源文件.删除源文件影响连接文件. echo 打印内容到屏幕 stat 查看文件状态 lstat 查看链接文件属性 ulimit 查看系统限制 ulimit -a查看所有限制.ulimit -n修改进程最大打开文件数. 最大打开文件数地设置有上限. env 显示环境变量 mkfifo 创建命名管道文件 Day02:01.IP和子网掩码:​ 1.网段 = 子网掩码 &amp; ip地址 ​ 2.ip地址由主机ID和子网ID组成 ​ 3.广播地址 .主机id为255. 例如, 192.168.1.255 02.管道(|):​ 1.左端输出内容作为右端的输入.例如, ​ ls | less \\ \\ ls的输出内容输入到less中 03.文件权限:1.每个文件都3组权限,针对创建用户,组用户和其他组用户.例如, ​ -rw-ew-e– linkCount groupName userName : 说明 描述 备注 - 文件类型 此处表示普通文件 r 可读 访问 w 可写 修改 x 可执行 linkCount 硬连接数 groupName 组名 userName 用户名 2./etc/group 文件查看组信息:例如, ​ groupName​ : x:1000 说明 描述 groupName 组名 x 加密 1000 组ID 3./etc/passwd 文件查看用户信息,例如: 04.vi编辑器:1.三种模式: ​ 编辑模式:写代码 ​ 命令模式:拷贝,撤销,分屏,删除…… ​ 末行模式:执行一些vi命令,设置命令,执行终端命令…… 2.快捷键和命令; 按键 作用 备注 shift + z + z 保存并退出 Ctrl + f 上一页 Ctrl + b 下一页 shift + v 以行为单位选中文本,配合h/j/k/l选择内容,d删除,y复制 ctrl + v y以列为单位选中文本,配合h/j/k/l选择内容,d删除,y复制 ctrl + r 反撤销 命令 作用 备注 命令模式 复制粘贴 dd/ndd 删除一行/删除多行 n是数字,表示行数 yy/nyy 复制一行/复制多行 n是数字,表示行数 p 粘贴 u 撤销 删除 [n]x 删除光标后n个字符 [n]X 删除光标前n个字符 D 删除光标所在位置到行尾 [n]dd 删除从当前位置的n行 dG 删除光标所在开始到文件尾的所有字符 dw 删除光标开始位置的字,包含光标所在位置 d0(数字) 删除光标前本行的所有内容,不包括光标所在字符 dgg 删除光标所在开始到文件行首第一个字符开始的所有字符 编辑和插入 I(大写i) 回到行首编辑 i 当前位置插入 o 下一行插入 O 上一行插入 a 光标右边插入 A 行尾插入 s 删除光标后字符,从光标当前位置插入 S 删除当前行,从行首插入 光标移动 gg 回到文件第一行行首 GG 到文件最后一行行首 nG或ngg 到指定行 n为行数 0(数字) 移动到行首 $ 移动到行尾 k/j/h/l(小写L) 上下左右移动光标 ^ 光标移动到本行第一个有效字符 撤销恢复 .(点) 执行上一次的操作 u 撤销前一个命令 ctrl + r 反撤销 100 + . 执行上一次操作100次 保存退出 ZZ 保存退出 查找替换 /字符串 从当前位置向下查找(n: 下一个,N: 上一个) ?字符串 从当前位置向上查找(n: 上一个,N: 下一个) r 替换当前字符 R 替换当前行光标后的一个字符 可视模式 v 按照字符移动,选中文本,配合h/j/k/l选择内容,d删除,y复制 shift + v 以行为单位选中文本,配合h/j/k/l选择内容,d删除,y复制 ctrl + v y以列为单位选中文本,配合h/j/k/l选择内容,d删除,y复制 末行模式 保存退出 :wq 保存退出 :x 保存退出 :w 路径 另存为 :q 退出,如果文件修改但没保存,会提示无法退出 :q! 强制不保存退出 all 表示所有 例如,:wqall //保存退出所有 替换 :s/src/dest 将光标所在行的第一个src替换成dest :s/src/dest/g 将光标所在行的所有src替换成dest :1,10s/src/dest/g 将1到10行的src全部替换为dest :%s/src/dest/g 当前文件src全部替换为dest :1,$s/src/dest/g 同上 :%s/src/dest/gc 同上,但需要用户确认 分屏 :sp [文件名] 文件水平分屏 不填写文件名表示当前文件分屏 :vsp [文件名] 文件垂直分屏 不填写文件名表示当前文件分屏 crtl + w + w 分屏之间切换 vim -O 文件1,文件2… 垂直分屏打开多个文件 vim -o 文件1,文件2… 水平分屏打开多个文件 拓展 :!man 3 printf 在vim执行man命令查看printf函数 !表示执行终端命令 :r !ls 将ls执行的内容读到vim中 :r 路径 将文件内容读到vim中 :w 路径 另存为 :w! 路径 强制另存为 :%s/;/\\r{\\r\\treturn 0;/r}\\r/g 将;替换成{return 0;} 原理见替换 :set nu 显示行号 :set nonu 隐藏行号 Day0301.gcc编译1.编译的步骤:预处理,编译,汇编,链接 步骤 语法 描述 预处理 gcc -E src.c -o dest.i——- 宏定义展开,头文件展开,删除注释,条件编译,不做语法检查 编译 gcc -S src.i -o dest.s 检查语法错误,生成汇编文件 汇编 gcc -c src.s -o dest.o 生成二进制文件 链接 gcc src.o -o dest 链接库,并生成可执行文件 2.gcc编译常用选项 选项 作用 形式 -v 显示版本号 gcc -v -g 包含调试信息调试 gcc src.c -o dest -g -D 编译时定义宏(条件编译) gcc src.c -o dest -D宏 -On (n为0~3的数字或s ,表示2.5) 设置编译优化级别,n为优化级别,3最高 gcc src.c -o dest -On -Wall 显示所有警告 gcc src.c -o dest -Wall -Werror 将警告显示为错误 gcc src.c -o dest -Wall -Werror 02.gdb调试1.给程序main函数传参数: ./程序 参数1 参数2…….. 2.gdb调试步骤 ​ ①用gcc包含调试信息编译程序 gcc src.c -o dest -g ​ ②设置断点 b/break [文件名:]行号/函数名 ​ ③维护断点 ​ ④调试 3.好的调试方法:生成core文件,到gdb中查看错误 ​ ulimit -c unlimited //用于设置环境,运行时会生成core文件描述错误信息 ​ gdb 可执行程序 core //查看core文件内容 gdb命令 作用 r/run 运行,如果有断点就停在断点处 q/quit 退出 set args 参数1,参数2 给程序传参数 show args 显示参数 start 程序执行一步,停止 n 程序向下执行一步 list [行数\\函数名] 显示10行,从某一行或某个函数处显示10行 set listsize 行数 设置list显示行数 b/break [文件名:]行数/函数名 在某文件的某一行或某函数入口处设置断点 b/break [文件名:]行号 if 变量名 == 值 如果文件中对应行号的变量满足条件则设置断点 d [断点编号] 删除断点,不填写编号删除所有断点, 可以一次删除多个断点.形式: d 1-2 disable 断点编号 让断点失效 enable 断点编号 让断点生效 step 进入函数 finish 退出函数 until 在一个循环内单步跟踪 c/continue 跳到下一个断点 i/info b/break 显示所有断点 p/printf 变量名 显示变量的值 display 变量名 设置自动显示变量 i/info display 显示自动显示的变量 undisplay 编号 取消自动显示变量 disable display 编号 隐藏自动显示变量 enable display 编号 激活自动显示变量 ptype 变量 查看变量类型 set var 变量 = 值 设置变量的值 03.静态库和动态库制作静态库:编译时静态链接(直接将库编译到执行文件中) 动态库:编译时只建立一个链接,运行时链接库执行 1.静态库静态链接的优缺点:​ ①优点: 不依赖运行环境 ​ ②缺点: ​ a&gt;可执行文件较大,占用磁盘空间,内存空间大 ​ b&gt;如果库改变需要重新编译 2.动态库动态链接的优缺点:​ ①优点: ​ a&gt;可执行文件小 ​ b&gt;如果库改变,不需要重新编译 ​ ②缺点: 依赖运行环境 3.静态库的制作​ ①制作: ​ a&gt;生成.o文件 gcc -c=- src.c -o dest .o ​ b&gt;打包成动态库ar -src libname.a src01.o src02.o src03.o 参数 描述 备注 ar ar工具,用于制作静态库 -r 更新 -c 创建 -s 建立索引 lib 库名前缀 name 库名 .a 静态库后缀 src01.o/src02.o/src03.o 二进制文件 一般写函数定义 ​ ②使用gcc编译: ​ gcc src.c -o dest -L动态库目录 -l(小写L)动态库名字(不包含前缀lib和后缀.a) -I(大写i)头文件目录,例如, ​ gcc -rcs .c -o dest -L./ -lname -I./ ​ 注意:如果不指定库的路径,可以将库放在/lib 或 /isr/lib目录下,可以默认收到 参数 描述 备注 -L 指定库路径 -l(小写L) 动态库名字 不包含前缀lib和后缀.a -I(大写i) 指定头文件目录 4.动态库的制作​ ①.制作: ​ a..生成.o文件: gcc -c: -fpic src.c -o dest ​ b..生成动态库: gcc -shared *.o -o libndyname.so 参数 描述 备注 -fpic 表示该库可以共享 -shared 编译动态库参数 lib 库前缀 dyname 动态库名字 .so 动态库后缀 ​ ②.使用gcc编译: ​ gcc src.c -o dest -L动态库目录 -l(小写L)动态库名字(不包含前缀lib和后缀.so) -I(大写i)头文件目录 参数 描述 备注 -L 指定库路径 -l(小写L) 动态库名字 不包含前缀lib和后缀.so -I(大写i) 指定头文件目录 ​ ③.动态库的特殊命令 命令 作用 形式 nm 查看库中包含的函数 nm libdyname ldd 查看可执行文件依赖的库 ldd dest ​ ④.动态库使用过程中出现的问题: ​ a&gt;运行程序时,载入器找不到需要载入的库,需要库的绝对路径 ​ 解决方法一(不推荐): 将库文件放到/lib或/usr/lib中 ​ 解决方法二(不推荐): 设置动态库为临时环境变量,另开终端失效 ​ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:动态库目录 ​ 解决方法三: 在~目录的.bashrc配置文件中加上方法二中的语句,每次 开机都会自动执行 ​ source .bashrc //重新加载.bashrc 立即生效刚刚加载的 脚本 ​ 解决方法四(常用): 在/etc/ld.so.conf 文件中添加动态库的绝对路径 ​ 执行ldconfig -v 重新加载配置文件并打印详细信息 ​ 解决方法五(不推荐): 在/lib或/usr/lib中建立动态库的软连接 04.makefile代码管理工具make [-f 自定义makefile文件名] [选项] [目标] 1.注意: ​ ①makefile会检测依赖项的修改时间,修改了才会执行下面命令 ​ ②makefile只执行第一条语句 2.makefile的命名: ​ ①一般文件名是: makefile或Makefile ​ ②自定义文件名的执行方式: make -f 文件名 3.makefile语法规则: 一条规则的格式: ​ 目标:依赖项(可以没有) ​ 命令列表(可以没有或多条命令) 例如, myAim:Aim01,Aim02 ​ ls ./ 4.makefile中的变量: ​ ①变量的定义: 变量名=变量值 ​ ②使用变量: 目标:$(变量名) ​ 依赖项和目标都可以定义为变量 5.只执行makefile中的某个规则: ​ make 规则名 6.makefile提供的变量 CC=gcc#arm-linux-gcc … 7.模式规则: 表示所有的.o文件依赖于同名的.c文件.形式如下, ​ %.o:%.c ​ 命令 8.makefile中的函数 函数 描述 形式 wildcard 获取一个目录中的指定类型文件(可以使用+=追加) SRC = $(wildcard ./*.c)———————- patsubst 替换变量中的内容 OBJS = $(patsubst %.c,%o,$(SRC)) 9.makefile中的伪目标: ①形式: .PHONY:依赖项​ ②不会检查检查有没有更新,直接执行命令 10.命令列表特殊符号: 特殊符号 作用 形式 - 命令出错也会继续向下执行 - 命令 @ 只执行命令,不显示执行的命令 @ 命令 10.makefile中的自动变量: 自动变量 描述 $@ 表示规则中的目标 $^ 表示规则中的所有依赖项 $&lt; 表示规则中的第一个依赖项 11.makefile选项: 选项 作用 -v 显示makefile版本 -w 显示makefile路径 -C(大写c) 切换工作路径 -n 只打印要执行的命令,但不执行 -s 只执行命令,但不打印要执行的命令 Makefile生成动态库文件1234567891011SRC=$(wildcard *.cpp)OBJS=$(patsubst %.cpp,%.o,$(SRC))GET=exe$(GET):$(OBJS)rm -rf main.og++ *.o -o libname.so -sharedpwd &gt;&gt; /etc/lb.so.confldconfigg++ main.cpp -o $(GET) -L./ -lname -I./%.o:%.cppg++ $^ -o $@ -c -fpic Day0401.linux下的文件IO1.系统调用:​ ①系统调用就是内核提供给用户的操作内核的接口 ​ ②系统调用通过中断通知内核 2.默认打开文件:​ ①启动进程时,默认打开标准输入(stdin)(文件标识符0),标准输出(stdout)(文件标识 符1)和标准错误文件(stderr)(文件标识符2) ​ ②STDIN_FILENO(标准输入编号宏),STDOUT_FILENO(标准输入编号 宏),STDERR_FILENO(标准输入编号宏), 3.perror函数: perror(“字符串”)​ ①具体步骤: ​ a&gt;先将字符串写入到stderr中 ​ b&gt;再将错误信息写入stderr ​ c&gt;stderr内容打印到屏幕上 ​ ②每个进程都有一个全局变量errno,来记录错误编号. ​ a&gt;打印错误信息的时候,会根据这个错误编号查找错误信息写入到stderr中; ​ b&gt;获得错误编号需要导入头文件 &lt;erron.h&gt;&lt;erron-base.h&gt; ​ c&gt;strerror(errno)用来解析错误信息 4.逻辑地址空间((虚拟地址空间)自下而上)(32位系统下):虚拟地址通过MMU映射到实际地址 存储内容 内存区 备注 pcb(用于保存进程信息)… 内核区 内核区大小1G,用户区大小3G 环境变量 命令行参数 栈区 存储方式从高地址到低地址 共享库 堆区 空间大 未初始化静态全局变量 静态全局区(bss) 已初始化地静态全局变量 静态全局区(data) 常量 静态全局区(data) 代码 text(代码区) 4k保护区 5.修改程序能打开地文件数量: ulmit命令 参数 作用 -a 查看系统一些限制 -n 文件数 根据-a显示地参数修改程序最大打开数 6.系统调用和库函数表 系统调用 作用 头文件 参数 备注 open(“路径”,打开方式) 打开文件 &lt;sys/types.h&gt;&lt;sys/stat.h&gt;&lt;fcntl.h&gt; 打开方式(必选项):————O_RDONLY(只读)|| O_WRONLY( 只写)|| O_RDWR(读写打开)||————还有其他可选项[| O_CREAT(创建) | O_EXCL(文件存在就报错,与O_CREAT一起使用) | O_TRUNC(清空) | O_APPEND(追加) | O_NONBLOCK(非阻塞标志位)] 返回值为int类型的文件描述符.一个程序默认能用的文件描述符最多为1024个.打开文件时,会寻找最小可用的文件描述符.与库函数fopen()不同的是,open()不存在缓冲区. open(“路径”,打开方式,文件权限) 打开文件 &lt;sys/types.h&gt;&lt;sys/stat.h&gt;&lt;fcntl.h&gt; 文件权限:同chmod数字法 write(文件描述符,数据首地址,写入数据地字节数) 向文件写入数据 &lt;unistd.h&gt; 写入成功返回值为写入地字节数,写入失败返回值为-1.写入地字节数要确定.设备文件可能会阻塞.可以加上O_NONBLOCK(阻塞标志位)来取消阻塞 read(文件描述符,存储地址,最大可读取字节数) 从文件中读取数据 &lt;unistd.h&gt; 返回值为读取数据地字节数.有多少数据读多少数据.最大可读取指定地字节数.设备文件和管道文件可能会阻塞.可以加上O_NONBLOCK(阻塞标志位)来取消阻塞. lseek(文件标识符,偏移量,参照位置) 移动光标 &lt;sys/types.h&gt;&lt;unistd.h&gt; 参照位置:SEEK_SET(文件头部) || SEEK_END(文件末尾) || SEEK_CUR(当前位置) 光标可以随意移动,但移动后文件大小不会变.需要再次写入.没有写入地位置默认用0填充. stat(“路径”,struct stat结构体指针) 获取文件状态信息 &lt;sys/types.h&gt;&lt;sys/stat.h&gt;&lt;unistd.h&gt; struct stat结构体指针需要先分配空间.(结构体中包含:文件的设备编号,节点,文件类型和存取权限,硬连接数,用户ID,组ID,(设备类型)若此文件为设备文件则为其设备号,文件字节数,块大小,块数,最后一次访问时间,最后一次修改时间,最后一次改变属性时间) 文件存在返回0,文件不存在返回-1. 参数中的文件类型和存取全选类型时mode_t,占16为.其中0-2位时其他组权限.3-5是组员权限.6-8是所有者权限.12-15位是文件类型. access(“路径”,权限) 判断文件权限 &lt;stdio.h&gt;&lt;unistd.h&gt; 权限:R_OK(可读) ||W_OK(可写)|| X_OK(可执行)||F_OK(文件是否存在) 有权限则返回0,失败则返回-1 chmod(“路径”,权限(八进制数)) 改变文件权限 &lt;sys/stat.h&gt; 成功返回0,失败返回-1 chown(“路径”,所有者ID,文件所属组ID) 改变文件所有者和所属组 &lt;unistd.h&gt; 成功返回0,失败返回-1 truncate(“路径”,指定文件大小) 修改文件大小 &lt;unistd.h&gt;&lt;sys/types.h&gt; 成功返回0,失败返回-1.缩小的话会删除后半部分内容 link(“路径”,”硬连接路径”) 创建一个硬连接 &lt;unistd.h&gt; 成功返回0,失败返回-1 symlink(“路径”,”软连接路径”) 创建一个软连接 &lt;unistd.h&gt; 成功返回0,失败返回-1 readlink(软连接名,存放软件对应名字,缓冲区大小) 读取软连接文件名 &lt;unistd.h&gt; 成功返回读到buf的内容,失败返回-1 unlink(删除文件路径) 删除一个软或硬连接文件 &lt;unistd.h&gt; 成功返回0,失败返回-1 rename(“原路径”,”更改后路径”) 重命名 &lt;unistd.h&gt; 成功返回0,失败返回-1 文件描述符的复制(代码块04-01) dup(旧的文件描述符) 赋值文件描述符 &lt;unistd.h&gt; 返回值为复制的文件描述符.新的文件描述符和旧文件描述符共享光标位置.文件描述符中有计数器,仅当最后一个文件描述符关闭时才关闭文件.否则仅仅断开文件描述符和文件的链接. dup2(文件描述符01,文件描述符02) 将文件描述符02指向文件描述符01 &lt;unistd.h&gt; 两个文件描述符共享光标位置.断开文件描述符02原来链接的文件,链接至文件描述符01指向的文件. fcntl(文件描述符,操作方式,…) 改变已打开的文件性质 &lt;unistd.h&gt;&lt;fcntl.h&gt; …:可变参数.针对操作方式的说明 成功,返回某个值.失败,返回-1 fcntl(文件描述符01,F_DUPFD,文件描述符02) 效果等同于dup2(文件描述符01,文件描述符02) fcntl(文件描述符01,F_GETFL,…) 获取文件状态标志 …:可变参数.此处会被忽略 返回值是int类型的文件的状态标志.通过&amp;操作可以判断打开文件时设置的状态. fcntl(文件描述符01,F_SETFL,…) 修改文件属性 …:可变参数.O_ARREND(追加) || O_ASYNC || O_DIRECT || O_NOATIME || O_NONBLOCK(非阻塞标志位) 可以通过上一个函数获取的文件状态标志进行设置之后作为第三个参数来设置文件状态. …… 库函数(代码块04-02) getcwd(存储路径的字符数组,字符数组的大小) 获取当前工作路径 &lt;unistd.h&gt; 返回值为当前路径,失败为NULL.效果等同于命令pwd chdir(‘’路径’’) 改变工作路径 &lt;unistd.h&gt; 返回值为0,失败为-1.效果等同于命令cd opendir(“目录路径”) 打开目录 &lt;sys/types.h&gt;&lt;dirent.h&gt; 返回值为(DIR*)类型的该目录结构体指针.失败返回NULL; closedir(目录结构体指针) 关闭目录 &lt;sys/types.h&gt;&lt;dirent.h&gt; 目录结构体指针:类型为DIR*.可以通过opendir()函数获取 返回值为0,失败为-1 readdir(目录结构体指针) &lt;dirent.h&gt; 目录结构体指针:类型为DIR*.参数内含成员:d_ino(此目录进入点的inode)||d_off(目录开头值次目录进入点的位移)||d_reclen(文件名长度) || d_name[] (文件名) 返回值为:struct dirent*类型的结构体流指针.读取结束返回值为NULL. time(&amp;time_t) 获取1970-01-01 00:00:00到现在的秒数 &lt;time.h&gt; &amp;time_t:一个time_t类型的变量 返回值为1970-01-01 00:00:00到现在的秒数 localtime(&amp;time_t) &lt;time.h&gt; &amp;time_t:一个time_t类型的类型变量 返回是类型为tm类型结构体指针,内部存储了各种格式的时间. asctime(&amp;time_T) 将时间转换成正常时间形式的字符串 &lt;time.h&gt; &amp;time_t:一个time_t类型的类型变量 Day0501.printf()打印内容到文件中:​ 方法一(dup): ​ ①关闭标准输出文件: close(STDOUT_FILENO) ​ ②复制要写入的文件描述符: int new_fd = dup(文件描述符) ​ ③printf() //打印内容到文件中 ​ 方法二(dup2): ​ ①替换文件描述符02指向内容到文件描述符01 dup2(文件描述符01,文件描述符 02) ​ ②printf() //打印内容到文件 02.多进程1.进程:​ ①程序:存储在磁盘上的一个可执行文件 ​ ②进程:运行的程序.进程相当于容器,这个容器中有可执行文件已经可执行程序运 行的资源.进程是操作系统对资源分配的最小单元. 2.并行和并发:​ ①并行:多个cpu处理多个任务 ​ ②并发:一个cpu处理多个任务 3.cpu中的并发原理:​ 进程挂在cpu中的红黑树上.每个节点有对应的时间片(用于表示时间长短).通过遍 历方式轮流执行 4.进程的状态;​ ①执行态(占用cpu运行) ​ ②就绪态(等待cpu运行) ​ ③等待态(等待某个条件,条件满足则进入就绪态) 5.进程控制块(PCB)​ ①一个存储进程信息的struct task_struct结构体,是进程存在的唯一标志.存在内核 区中. ​ ②若父进程未结束,子进程结束.则其他资源被回收,而PCB进程控制块不会被回收, 等待父进程回收. 6.进程号(PID):​ ①0号进程用来调度,所有的进程都由1号进程直接或间接创建. ​ ②进程号类型为pid_t,范围0~32767 ​ ③每个进程的pid是唯一的 ​ ④进程号(PID),父进程号(PPID),进程组号(PGID): ​ a&gt;父进程号:创建该进程的进程号 ​ b&gt;组进程号:把一些进程放入一个组,每个组都有一个组长,组长id就是组id ​ ⑤标准输出在windows和linux下的区别 系统 文件类型 刷新条件 windows 无缓存区 linux 普通文件 缓存区满,强制刷新fflush,程序退出 linux 标准输出文件 缓存区满,强制刷新fflush,程序退出,行缓存’\\n’ 7.环境变量​ ①每个进程都有自己的环境变量 ​ ②环境变量相当于进程的全局变量 ​ ③子进程会拷贝父进程的环境变量 ​ ④终端查看环境变量命令: env ​ ⑤部分环境变量: ​ a&gt;PATH: 系统根据PATH寻找可执行程序 ​ b&gt;HOME: 家目录 ​ c&gt;PWD: 当前工作路径 ​ ……… 8.僵尸进程​ ①定义: 子进程退出,父进程没有回收子进程的进程控制块(PCB) ​ ②注意: 当子进程退出收,子进程的堆,栈,静态全局变量等用户数据都会被释放,但 是内核空间的子进程的PCB不会被释放,所以要回收.当父进程也结束时,系统会 自动回收父进程和子进程的所有资源. ​ ③僵尸进程不能被杀死,只能由父进程来回收,或者父进程结束时系统进行回收. 9.孤儿进程​ ①定义: 父进程结束,子进程没结束.此时子进程被称为孤儿进程. 10.守护进程​ ①定义: 特殊的孤儿进程.在后台运行.不受终端控制. 11.判断子进程是否正常退出​ ①wait()获取退出状态: wait(&amp;status) ​ ②使用宏函数: WIFEXITED(status). 通过返回值判断 12.父子进程的内存共享​ 读取时共享物理内存,写时复制内容到新的物理内存地址. 13.fork之后的文件描述符(代码块05-01)​ 父进程通过fork函数创建的子进程会拷贝父进程的文件描述符,同时指向同一个文 件,共享光标位置. 14.父子进程间的默认打开文件​ fork()父子进程间公用标准输入(stdin),有独自的标准输出(stdout) ​ 进程操作函数表(代码块05-(02-04) ) 接口 作用 参数 备注 pid_t getpid() 获得进程号 返回值为pid_t类型变量. pid_t getppid() 获得父进程号 返回值为pid_t类型变量. pid_t getpgid(pid_t) 获得进程组号 pid_t:0~32767之间的无符号数 返回值为pid_t变量类型. pid_t fork() 以复制父进程的方式(包含文件描述符等运行状态)创建子进程. 创建成功,子进程中返回0,父进程返回子进程的id号.失败返回-1.子进程同时复制了进程的运行状态.父子进程相对独立. pit_t vfork() 创建子进程.但不复制父进程内容,在exec之前,子进程运行在父进程空间中.没有自己空间 创建成功,子进程中返回0,父进程返回子进程的id号.失败返回-1.vfork()函数创建的子进程原理相当于重定向的两个指针指向同一块空间.且此时子进程会继续向下执行.在exec后,才没有同指向问题.其中,主进程在 调用exec函数族或exit()之前会等待vfork()子进程 char* getenv(“key”) 获取环境变量 key:环境变量名 pid_t wait(int* status) 等待任意子进程终止.如果子进程终止,此函数会回收子进程资源. status:用于存储子进程退出信息的整型变量地址.非0为正常退出,0为不正常退出. 返回值为回收该资金的进程号.调用wait()函数的父进程会挂起,直到他的一个子进程退出或者收到一个不能被忽视的信号才会被唤醒.宏函数:WIFEXITED(status)(取0-7位,用于判断是否正常退出) || WEXITSTATUS(status)(取返回值8-15位) WIFEXITED(int status) 通过wait函数的status参数判断子进程是否正常退出 取status的0-7位 WEXITSTATUS(int status) 取子进程的返回值 取status的8-15位 pid_t waitpid(pid_t pid,int* status,int options) 等待指定的子进程终止并回收资源 {pid: &gt;0:等待子进程的id. || =0: 等待任意子进程,如果子进程已加入别的进程组则不等待. || =-1 等待任意子进程,等同于wait. || &lt;-1 等待指定进程组的任意子进程. } {status:同上wait函数 } {options: 0:阻塞父进程,等待子进程退出. || WNOHANG: 没有任何已经结束的子进程,则立即返回. || WUNTRACED:如果子进程暂停了则此函数立即返回,却不予理会子进程的结束状态.(跟踪调试,很少用到) } 返回值为子进程id,如果第三个参数设置为WNOHANG则有可能返回0,失败则返回-1(一般情况下,-1表示回收完毕) exec函数族 exec的原来的进程号,环境变量等不会改变 int execl(const char* path_name, const char* arg0, const char* arg1, …,NULL) 在一个进程中启动另一个可执行程序.新的程序会占用原进程地址空间,且程序从新进程的main函数开始执行. {path_name:可执行程序的路径 }{ arg0: 可执行程序名 }{arg1,….:为可执行程序传入的参数 } 返回值无.失败则返回-1 int execlp(const char* file_name, const char* arg0, const char* arg1, …,NULL) 同上.会根据环境变量PATH寻找应用程序 {file_name:PATH下的程序名 }{ arg0: 可执行程序名 }{arg1,….:为可执行程序传入的参数 } 返回值无.失败则返回-1 int execle(const char* path_name, const char* arg0, const char* arg1, …,NULL,char *const envp[]) 同execl.同时改变环境变量 {path_name:可执行程序的路径 }{ arg0: 可执行程序名 }{arg1,….:为可执行程序传入的参数 }{envp[]:环境变量 } 返回值无.失败则返回-1 int execv(const char *path_name, char *const argv[]) 同execl,参数可以放入argv数组中 {path_name:可执行程序的路径 }{ argv: 可执行程序的参数存储的数组 } 返回值无.失败则返回-1 exit(int return_value) 退出进程 {return_value:返回值 } 一般用于exec函数族下保证子进程正常退出 问题1.fcntl()函数的使用 2.其他系统调用的基本使用 3.默认打开文件标识符对应宏的记忆 4.目录操作库函数的使用 5.多进程的使用 6.多进程操作中的深浅拷贝问题 7.使用wait函数和waitpid函数,同时判断进程是否正常退出 8.vfork函数配合exec函数族创建子进程,以及存在的重定义的问题 9.父子进程读时共享,写时复制的深入了解 10.fork()下子进程的文件描述符 Day0601.进程间的通信1.单工,全双工,半双工的概念:​ ①只能单向传输 ​ ②同一时刻双向传输 ​ ③同一时刻只能单向传输 2.无名管道(pipe)​ ①只能在由血缘关系的进程中使用 ​ ②存在于内存中 ​ ③三大特点: ​ a&gt;读取默认阻塞,如果管道的写端都关闭,则读取不带阻塞 ​ b&gt;缓存区满时写入阻塞 ​ c&gt;如果读端都关闭,向管道中写入会接收到系统的SIGPIPE信号,退出进程. ​ d&gt;读取默认带阻塞 3.命名管道(fifo)​ ①命名管道特点: ​ a&gt;fifo管道文件存在磁盘上,且只有打开fifo管道时才会映射到内存缓冲区中读写 数据. ​ b&gt;fifo管道文件的缓冲区大小由系统决定. ​ c&gt;当fifo的进程退出后,fifo文件将继续保存在文件系统中以便之后继续使用. ​ d&gt;fifo可以用于不相关的进程间的通信. ​ ②以可读可写方式打开命名管道的特点: ​ a&gt;read默认带阻塞 ​ b&gt;缓存区满时写入阻塞 ​ c&gt;只要由一个使用命名管道的进程,那么管道缓冲区内的内容就不会被销毁 ​ ③以只读或只写打开命名管道的特点: ​ a&gt;以只读或只写的方式打开管道,open函数默认带阻塞,等到读写端都打开才不 带阻塞 ​ b&gt;通信过程中,读取默认阻塞,如果管道的写端都关闭,则读取不带阻塞 ​ c&gt;缓存区满时写入阻塞 ​ d&gt;通信过程中,如果读端都关闭,向管道中写入会接收到系统的SIGPIPE信号,退 出进程 ​ e&gt;读取默认带阻塞 ​ ④以只读或只写打开命名管道特点(设置O_NONBLOCK非阻塞标志位): ​ a&gt;以只写方式打开,open不阻塞,open打开文件会失败 ​ b&gt;以只读方式打开,open不阻塞,open成功 4.共享存储映射(mmap)(代码块06-03)​ ①原理:将文件映射到进程对应的内存中,对内存中的内容进行读写操作,会对文件中 的内容.相对的,改变文件中的内容,也会改变进程中映射的地址内容.相对于 使用普通的文件操作没有页缓存,效率更高. ​ ②注意: ​ a&gt;mmap映射的文件需要通过truncate函数增加文件大小.避免出现0字节文件 ​ b&gt;偏移量大小为4096的倍数,因为linux下的文件系统4096为一页 ​ c&gt;映射完成之后,关闭文件不影响映射 ​ d&gt;解除映射的地址必须是mmap的返回地址 ​ e&gt;系统默认的映射区的大小为4096的倍数,函数会默认帮助补全成4096的倍数 ​ f&gt;映射时会默认执行一次读操作.所以不能只写打开文件. ​ g&gt;打开文件的权限要大于等于对于映射区的权限. ​ h&gt;对返回值进行判断. 5.信号(代码块06-04)​ ①信号的特点: ​ 简单,携带信息量小,优先级高,信号是一步通信,由内核发送. ​ ②产生信号: ​ a&gt;按键产生: ctrl + z , ctrl + c ,ctrl + \\ ​ b&gt;调用系统调用函数或库函数: kill , raise , abort ​ c&gt;终端命令kill ​ d&gt;硬件错误: 无效的内存访问(段错误) 除数为0 ​ e&gt;软件产生: 定时器 alarm ​ ③信号由内核送到用户进程: ​ a&gt;递达: 信号到达用户进程,用户处理信号 ​ b&gt;未决: ​ ④信号处理流程: ​ 先通过未决信号集,再通过阻塞集.集中使用位表示信号.未决信号集和阻塞集存 在PCB(进程控制块)中. ​ ⑤信号的默认处理方式: ​ a&gt;终止进程(Term) ​ b&gt;忽略信号(Ign) ​ c&gt;产生core文件(Core) ​ d&gt;暂停(Stop) ​ e&gt;继续(Cont) ​ ⑥信号的自定义处理方式 ​ a&gt; 捕捉信号,调用自定义回调 ​ ⑦查询信号编号: ​ kill -l(小写L) ​ ⑧查询信号表: ​ man 7 signal ​ ⑨信号集: ​ a&gt;信号集是一个容器里都是型号.数据类型是sigset_t. ​ b&gt;未决信号集不可修改,阻塞集可以修改. ​ ⑩信号不支持排队: ​ 如果阻塞集中将sig信号加入阻塞集,信号sig到达时处于未决态,这个信号从阻塞 集中提出,原来未决的信号可以到达进程,被进程处理.(Ps:sleep()函数是使进程被 挂起,挂起中的如果被信号终端,不会再挂起,执行完中断程序,程序会跳过sleep, 从sleep之后运行) 6.守护进程(代码06-06):​ ①定义和创建方法: ​ a&gt;不受终端控制,脱离终端 ​ b&gt;终端直接运行可执行程序,终端会产生信号杀死该进程 ​ c&gt;终端之间运行./a.out &amp;运行,程序在后端运行,不会收到终端信号影响,但如果终 端退出,会给从终端启动的所有进程发送SIGHUP信号 ​ d&gt;终端直接 nohup ./a.out &amp; 运行,不会收到终端的信号影响,而且会屏蔽 SIGHUP信号 ​ ②会话: ​ a&gt;定义:多个进程组 ​ b&gt;父进程不能创建会话,子进程可以创建会话 ​ ③创建守护进程: ​ a&gt;创建子进程,父进程退出,为了创建孤儿进程. ​ b&gt;子进程调用setsid()函数脱离终端控制 ​ c&gt;切换工作目录 chdir()函数 ​ d&gt;重新设置文件掩码(可以不做) ​ e&gt;关闭不需要的文件描述符0,1,2 close()函数 ​ f&gt;子进程任务 ​ g&gt;收尾 ​ 进程通信函数表(代码块06-(01-06) ) 接口 作用 头文件 参数 备注 int pipe(int pipefd[2]) 创建无名管道用于血缘关系进程间通信 &lt;unistd.h&gt; {pipefd(输出参数):读写两端文件描述符存储的数组.fd[0]是读取端,fd[1]是写入端 } 返回值为0,失败为-1.读取管道内容默认发生阻塞.向缓存区已满管道写入内容也会产生阻塞.当读写端口都关闭时,如果向管道中写入内容会接收到系统发送的SIGPIPE信号而退出进程. int mkfifo(const char* path_name, mode_t mode) 创建fifo有名管道用于任意进程间的通信 &lt;sys/types.h&gt;&lt;sys/stat.h&gt; {path_name: 管道文件的保存路径 }{mode: 管道文件的权限(可用数字法) } 返回值0,失败返回-1.若存在同名文件则创建文件失败 void* mmap(void* addr, size_t len, int prot, int flags, int fd, off_t offset) 创建映射区 &lt;sys/mman.h&gt; {addr地址: 映射的内存地址 填NULL 表示程序自动寻找 }{len:申请映射区的大小,映射区的大小自动补全为4096的倍数 }{prot: PROT_READ(可读)|| PROT_WRITE(可写) }{flags:MAP_SHARED(共享的,修改映射区会影响源文件)||MAP_PRIVATE(私有的) } {fd:文件描述符 }{offset:指定一个偏移位置,从偏移位置开始映射.大小必须是4096的倍数,因为linux下文件系统一页大小为4096} 返回值为映射区的首地址,失败为MAP_FAILED((void*)(-1)). a&gt;mmap映射的文件一般需要通过truncate函数增加文件大小.避免出现0字节文件 b&gt;偏移量大小为4096的倍数,因为linux下的文件系统4096为一页 c&gt;映射完成之后,关闭文件不影响映射 d&gt;解除映射的地址必须是mmap的返回地址. e&gt;系统默认的映射区的大小为4096的倍数,函数会默认帮助补全成4096的倍数. f&gt;映射时会默认执行一次读操作.所以不能只写打开文件. g&gt;打开文件的权限要大于等于对于映射区的权限. h&gt;对返回值进行判断. int munmap(void* addr, size_t length) 解除映射区 &lt;sys/mman.h&gt; {addr地址: 映射的内存地址 必须是mmap函数返回的地址 } {length:映射区的大小 } 返回值为0,失败为-1. int kill(pid_t pid, int signal) 给进程发送信号 &lt;signal.h&gt;&lt;sys/types.h&gt; {pid: 进程号 &gt;0:指定进程号发送信号|| =0:给同一进程组发送信号|| &lt;-1:发送信号给指定进程组|| =-1:发送信号给系统所有进程,前提是有权限 } {signal: 信号编号.可以通过man 7 signal查询信号表 } 返回值0,失败返回-1. int raise(int signal) 给当前进程发送信号 &lt;signal.h&gt; {signal: 信号编号.可以通过man 7 signal查询信号表 } f返回值为0,失败为其他值. void abort(void) 给自己发送异常终止信号SIGABRT(6) &lt;stdlib.h&gt; 没有返回值.会生成core文件,但要先通过命令limit -c ulimited修改系统设置. unsigned int alarm(unsigned int seconds) 定时给当前进程发送SIGALRM(14).用于定时自杀 &lt;unistd.h&gt; {seconds: 发送信号的秒数 } 返回值:上一次闹钟剩余的秒数. sighandler_t signal(int signum, sighandler_t handler) 修改某个信号的动作,并且可以捕捉 &lt;signal.h&gt; {signum:修改的信号编号 }{handler: 回调函数的入口,可以填写SIG_IGN(忽略)或SIG_DFL(执行默认动作)} f返回值:函数入口地址.typedef void (*sighandler_t)(int).handler_t的类型为. int setitimer(int which, const struct* itimerval new_value, struct itimerval* old_ovalue) 设置周期性闹钟触发信号 &lt;sys/time.h&gt; {which: ITIMER_REAL(产生SIGALRM(14)信号)|| ITIMER_VIRTUAL(产生SIGVTALRM(26)信号)|| ITIMER_PROF(产生SIGPROF(27)信号) }{new_value和old_value(输出参数): 设置闹钟的周期性时间. struct itimerval{ struct timerval it_interval;(周期时间) struct timerval it_value;(闹钟第一次时间) } struct timeval {time_t tv_sec;(秒) suseconds_t tv_usec;(微秒);}} 成功返回0,失败返回-1..第一次设置的时间可以和后面的时间周期不一样.例如,第一次计时10秒,以后每一次都为5秒. 信号集操作函数(代码块06-06) &lt;signal.h&gt; 实际是操作阻塞集 int sigemptyset(sigset_t* set) 清空信号集 &lt;signal.h&gt; {set:信号集指针 } 返回0,失败返回-1. int sigfillset(sigset_t* set) 将所有信号加入信号集 &lt;signal.h&gt; {set:信号集指针 } 返回0,失败返回-1. int sigaddset(sigset_t* set, int signum) 将信号signum加入信号集 &lt;signal.h&gt; {set:信号集指针 }{signum: 信号 } 返回0,失败返回-1. int sigdelset(sigset_t* set, int signum) 将信号signum从信号集删除 &lt;signal.h&gt; {set:信号集指针 }{signum: 信号 } 返回0,失败返回-1. int sigismember(const sigset_t* set, int signum) 判断信号是不是信号集成员 &lt;signal.h&gt; {set:信号集指针 }{signum: 信号 } 是成员返回1,不是成员返回0,错误返回-1. int sigprocmask(int how, const sigset_t* set, sigset_t* old_set) 修改进程的阻塞集 &lt;signal.h&gt; {how: SIG_BLOCK(将set集合添加到阻塞集中)|| SIG_UNBLOCK(将set集合从阻塞集中删除)|| SIG_SETMASK(将set集合设置为阻塞集) }{set:用来修改阻塞集的信号集(删除,添加,设置) }{old_set(输出参数):保存修改前的阻塞集 } 返回值为0,失败为-1. int sigpendint(sigset_t* set) 获取未决信号集 &lt;signal.h&gt; {set(输出参数):用于保存未决信号集 } 返回值为0,失败返回-1.未决信号集不能修改 int sigaction(int signum, const struct sigaction* act, struct sigaction* old_act) 修改信号的处理方式,并捕捉信号,调用回调函数 &lt;signal.h&gt; {signum:信号 }{act:修改信号处理动作和回调函数的结构体,包含回调函数指针.内容包括,回调函数指针,临时阻塞集,…}{old_act:保存修改之前信号的处理动作和回调函数等 } 返回值为0,失败为-1. 会话(代码06-06) pid_t getsid(pid_t pid) 获得会话号 &lt;un&lt;sistd.h&gt; {pid:进程号 =0:当前进程会话id ||&gt;0:指定进程会话id } 返回值为0,失败返回-1 pid_t setpgid(pid_t pid, pid_t pgid) 将进程加入其他进程组 &lt;unistd.h&gt; {pid:进程号 }{pgid: 进程组号 } 返回值为0,失败返回-1. pid_t setsid() 创建一个会话 &lt;unistd.h&gt; 返回值创建成功的会话id.失败返回(pid_t)-1.父进程不能创建会话,只有子进程可以创建会话. 问题1.pipe匿名管道和fifo命名管道的使用 2.通过管道实现qq通信功能 3.阻塞集和未决信号集的回顾 4.信号函数的综合使用 5.用alarm函数实现setitimer函数 Day07:01.多线程​ 编译多线程程序需要加参数 -lpthread 1.定义:​ ①每个进程都有地址空间和一个主线程(控制线程),即main函数. ​ ②每个线程有独立的栈区. 2.进程与线程的对比:​ ①线程是cpu调度和分配的基本单位 ​ ②线程一般不拥有资源.(除了必不可少的程序计数器等.) ​ ③线程采用共享内存的方式通信,效率高. ​ ④并发性. 3.查看最大创建线程数:​ cat /proc/sys/kernel/… 4.线程的两种状态:​ joinable和unjoinable 5.线程的退出:​ pthread_exit(void* retval) ​ 线程退出不能使用exit()函数,exit函数会导致整个进程退出.pthread_exit只会退 出当前进程.如果主线程调用pthread_exit函数,主线程退出,子线程还能继续运行. 6.线程的取消:​ 线程要遇到取消点才能被pthread_cancel函数取消.取消点包含常见的库函数和 系统调用. 7.线程属性的设置 pthread_create函数中的attr参数​ ①线程状态设置地接口都是由pthread_attr_开头 ​ ②线程属性结构体: ​ typedef struct{ ​ }pthread_attr_t ​ ③步骤: ​ a&gt;定义结构体: pthread_attr_t attr; ​ b&gt;初始化: pthread_attr_init(&amp;attr); ​ c&gt;设置分离属性: ​ pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED) 02.线程的同步和互斥1.定义: ​ a&gt;互斥:多线程对同一资源进行访问,同一时刻只允许1一个线程访问资源,访问 需要互斥 ​ b&gt;同步:在互斥的基础上,多线程有一定的先后顺序 2.实现互斥的方法: 互斥锁, 信号量 3.初始化互斥锁: ​ ①方法一: pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; ​ //此方法只能初始化一把锁 ​ 方法二: ​ pthread_mutex_t mutex; ​ pthread_mutex_init(&amp;mutex, NULL); 4.死锁: ​ ①定义: 当两个进程使用的公共资源有两把线程锁时,每个进程都持有一把 锁申请第二把锁时,会一直阻塞.这种现象就称为死锁. ​ ②解决方法: ​ a&gt;业务上规定上锁的顺序. ​ b&gt;如果申请上锁失败,则解开原来持有的线程锁. ​ ③可能造成死锁的原因: ​ a&gt;上锁后不解锁 ​ b&gt;多线程申请锁的顺序不一致,导致每个线程持有不同的线程锁,造成一直 阻塞 5.读写锁 ​ ①为了解决一个线程在读取时,可以让其他线程同时读取.但读取时不能写.相对的, 写入时也不能读取. ​ ②读写锁的三种状态: 未锁, 加读锁, 加写锁 ​ ③特性: 读共享,写独占,写锁优先级高! 6.信号量: ​ ①信号量用于进程和线程的同步和互斥,本质时一个非负整数的计数器. ​ ②信号量的值表示可持有锁的数量,每次上锁计数器减一.计数器为0时阻塞. ​ 多线程函数表 接口 作用 头文件 参数 备注 int pthread_create(pthread_t* pthread, const pthread_attr_t* attr, void* (start_routine)(void * ), void arg ) 创建一个线程 &lt;pthread.h&gt; {pthread:线程号的地址 }{attr: 线程的属性(线程的大小,是否与当前进程分离) }{start_routine:回调函数指针 }{arg:回调函数参数 } 返回值为0,失败返回-1. {attr:线程状态设置地接口都是由pthread_attr_开头} int pthread_join(pthread_t pthread, void** retval) 等待子线程结束,并回收子进程资源 &lt;pthread.h&gt; {pthread:被等待的进程号 }{retval(输出参数): 存储线程退出状态指针的地址 } 成功返回0,失败返回其他值. int pthread_detach(pthread_t pthread) 线程分离,不用进程回收资源 &lt;pthread.h&gt; {pthread:线程号 } 成功返回0,失败返回-1. void pthread_exit(void* retval) 退出调用线程 &lt;pthread.h&gt; {retval(输出参数):保存子进程退出时的状态 } 没有返回值 pthread_equal(pthread_t t1, pthread_t t2) 比较两个线程号是否相等 &lt;pthread.h&gt; {t1:线程号 }{t2:线程号 } 返回非0值,不相等返回0 int pthread_cancel(pthread_t thread) 指定线程号取消线程 &lt;pthread.h&gt; {thread:线程号 } 返回0,失败返回非0. int pthread_setcancelstate(int state, int* old_state) 设置线程能否被pthread_cancel取消的状态 &lt;pthread.h&gt; {state:线程能否被取消的状态 PTHREAD_CANCEL_ENABLE:能被取消|| PTHREAD_CANCEL_DISABLE:不能被取消 }{old_state:保存老的线程能否取消的设置 } 返回0,失败返回非0.子线程调用的代码块中要有取消点才能被取消.取消点有常用的库函数和系统调用. int pthread_setcanceltype(int type, int* old_type) 设置线程需不需要遇到取消点才能取消 &lt;pthread.h&gt; {type: 设置取消是否需要取消点的状态 PTHREAD_CANCEL_ASYNCHRONOUS:不需要遇到取消点就能取消 || PTHREAD_CANCEL_DEFERRED:需要遇到取消点才能取消 }{old_type:保存老的设置状态} 返回0,失败返回非0. void pthread_testcancel() 设置线程取消点 &lt;pthread.h&gt; 没有返回值. 互斥与同步 int pthread_mutex_init(pthread_mutex_t* mutex, const pthread_mutexattr* attr) 初始化互斥锁 &lt;pthread.h&gt; {mutex: 锁的地址 }{attr:设置锁的初始状态 } 返回0,失败返回其他. int pthread_mutex_destroy(pthread_mutex_t* mutex) 销毁互斥锁 &lt;pthread.h&gt; {mutex: 锁的地址 } 返回0,失败返回其他. int pthread_mutex_lock(pthread_mutex_t* mutex) 申请上锁 &lt;pthread.h&gt; {mutex: 锁的地址 } 返回0,失败返回-1.如果锁已经处于lock状态,则阻塞.处于unlock状态就上锁成功. int pthread_mutex_trylock(pthread_mutex_t* mutex) 尝试申请上锁 &lt;pthread.h&gt; {mutex: 锁的地址 } 返回0,失败返回-1.如果锁已经处于lock状态,不阻塞.处于unlock状态就上锁成功. int pthread_mutex_unlock(pthread_mutex_t* mutex) 解开互斥锁 &lt;pthread.h&gt; {mutex: 锁的地址 } 成功返回0,失败返回其他值. 读写锁 int pthread_rwlock_init(pthread_rwlock_t * rwlock,const pthread_rwlockattr_t * attr) 动态初始化读写锁 &lt;pthread.h&gt; {rwlock:读写锁地址 }{attr:读写锁属性 } 成功返回0,失败返回其他值. int pthread_rwlock_destroy(pthread_rwlock_t *rwlock) 销毁读写锁 &lt;pthread.h&gt; {rwlock:读写锁地址 } 成功返回0,失败返回其他值. int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock) 申请上读锁 &lt;pthread.h&gt; {rwlock:读写锁地址 } 成功返回0,其他返回其他值.如果读锁处于lock状态则上锁失败,阻塞.如果读锁处于lock,则不阻塞,上锁成功 int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock) 尝试申请上读锁 {rwlock:读写锁地址 } 成功返回0,其他返回其他值.如果读锁处于lock状态则上锁失败,但不阻塞.如果读锁处于lock,则不阻塞,上锁成功 int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock) 申请上写锁 &lt;pthread.h&gt; {rwlock:读写锁地址 } 成功返回0,失败返回其他..不管读锁或写锁处于lock状态,都阻塞. int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock) 尝试申请上写锁 {rwlock:读写锁地址 } 成功返回0,失败返回其他..不管读锁或写锁处于lock状态,都不阻塞. int pthread_rwlock_unlock(pthread_rwlock_t *rwlock) 解开读写锁 &lt;pthread.h&gt; {rwlock:读写锁地址 } 返回0,失败返回其他值. 条件变量 int pthread_cond_init(pthread_cond_t* cond, const pthread_condattr_t* attr) 动态初始化条件变量 &lt;pthread.h&gt; {cond: 条件变量的地址 }{attr: 属性的地址 } 返回0,失败返回其他值. int pthread_cond_destroy(pthread_cond_t* cond) 销毁条件变量 &lt;pthread.h&gt; {cond: 条件变量的地址 } 返回0,失败返回其他值. int pthread_cond_timedwait(pthread_cond_t* cond, pthread_mutex_t* mutex, const struct timespec* abstime) 等待时间 解锁,等待条件,抢锁(前两部不可分隔) &lt;pthread.h&gt; {cond:条件变量的地址 }{mutex:互斥锁的地址 }{abstime: 距离1970年1月1日的绝对秒数} 返回0,失败返回其他值.当等待时间到达时,即使阻塞也会去抢锁. int pthread_cond_wait(pthread_cond_t* cond, pthread_mutex_t* mutex) 解锁,等待条件,抢锁(前两部不可分隔) &lt;pthread.h&gt; {cond:条件变量的地址 }{mutex:互斥锁的地址 } 返回0,失败返回其他值. int pthread_cond_signal(pthread_cond_t* cond) 给阻塞在条件变量上的一个线程发送信号,提示条件满足 &lt;pthread.h&gt; {cond:条件变量的地址 } 返回0,失败返回其他值. int pthread_cond_broadcast(pthread_cond_t* cond) 给阻塞在条件变量的所有线程发信号,提示条件满足 &lt;pthread.h&gt; {cond:条件变量的地址 } 返回0,失败返回其他值. 信号量(代码07-01) int sem_init(sem_t* sem,int pshared, unsigned int value) 初始化信号量 &lt;pthread.h&gt; {sem:信号量的地址 }{pshared: =0:线程间共享 || =1:进程间共享 }{value:信号量的初始值. } 返回0,失败返回-1. int sem_wait(sem_t* sem) 将信号量减一,如果信号量为0,则阻塞.大于0,则减一. &lt;semaphore.h&gt; {sem:信号量的地址 } 返回0,失败返回-1. int sem_trywait(sem_t* sem) 尝试将信号量减一,如果信号量为0,不阻塞.大于0,则减一. &lt;semaphore.h&gt; {sem:信号量的地址 } 返回0,失败返回-1. int sem_timedwait(sem_t *sem, const struct timespec *abstime) 将信号量减一,如果信号量为0,则阻塞.大于0,则减一.如果时间到达则不阻塞,立即返回. &lt;semaphore.h&gt; {sem:信号量的地址 }{abstime: 距离1970年1月1日的绝对秒数 } 返回0,失败返回-1. int sem_post(sem_t* sem) 将信号量加一 &lt;semaphore.h&gt; {sem:信号量的地址 } 返回0,失败返回-1. int sem_destroy(sem_t* sem) 销毁信号量 &lt;semaphore.h&gt; {sem:信号量的地址 } 返回0,失败返回-1. int sem_getvalue(sem_t* sem,int* sval) 获取信号量的值 &lt;semaphore.h&gt; {sem:信号量的地址 }{sval:保存信号量值的地址 } 返回0,失败返回-1. 问题:1.线程函数地使用 2.创建线程并设置相关属性 3.互斥锁和信号量区别的对比 代码块maday04:04-01:123456789101112131415161718192021222324252627282930 1 #include &lt;stdio.h&gt; 2 #include &lt;iostream&gt; 3 #include &lt;sys/types.h&gt; 4 #include &lt;sys/stat.h&gt; 5 #include &lt;fcntl.h&gt; 6 #include &lt;unistd.h&gt; 7 8 int main() 9 &#123;10 //以读写方式打开文件,若文件不存在旧创建11 int fd01 = open(\"./fcntl.txt\",O_RDWR | O_CREAT);12 //判断文件是否打开成功 13 if (fd01 &lt; 0) &#123;14 perror(\"open\");15 return -1;//open file failed...16 &#125; 17 //一个新的文件标识符指向文件18 int fd02 = dup(fd01);19 //将标准输出的文件表示符指向文件20 dup2(fd02,STDOUT_FILENO);21 //效果等于dup2()函数22 fcntl(fd01,F_DUPFD,STDIN_FILENO);23 //获取文件状态标志24 int flag = fcntl(fd01,F_GETFL);25 //将文件状态设置为追加26 flag |= O_APPEND;27 fcntl(fd01,F_SETFL,flag);28 29 return 0;30 &#125; 04-02:12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt; 2 #include &lt;iostream&gt; 3 #include &lt;unistd.h&gt; 4 #include &lt;sys/types.h&gt; 5 #include &lt;dirent.h&gt; 6 #include &lt;time.h&gt; 7 8 9 int main() 10 &#123; 11 char path_name[256]; 12 //获取当初工作路径,参数: 存储目录的地址空间,字符数组大小 返回值:工作路径 失败会犯NU 13 getcwd(path_name,sizeof(path_name)); 14 //改变工作路径 参数:路径 15 chdir(\"../\"); 16 chdir(\"./Day05\"); 17 //打开目录 参数:目录路径 返回值:DIR*目录类型的结构体指针 失败返回NULL 18 DIR* dir = opendir(path_name); 19 //读取目录内容 参数:DIR*结构体指针 返回值:目录结构体流指针 20 struct dirent* ddir; 21 while(ddir = readdir(dir)) &#123; 22 printf(\"%s\\n\",ddir-&gt;d_name); 23 &#125; 24 //关闭目录 参数:DIR*目录结构体指针 返回值:0,失败返回-1 25 closedir(dir); 26 27 return 0; 28 &#125; 05-01:12345678910111213141516171819202122232425262728 1 #include &lt;stdio.h&gt; 2 #include &lt;unistd.h&gt; 3 #include &lt;fcntl.h&gt; 4 #include &lt;sys/types.h&gt; 5 #include &lt;sys/stat.h&gt; 6 #include &lt;iostream&gt; 7 8 int main() 9 &#123;10 //创建子线程并使用文件描述符11 int fd = open(\"./txt\",O_RDWR | O_CREAT, 0644);12 13 pid_t pid = 0;14 pid = fork();15 if (pid &lt; 0) &#123;16 printf(\"fork failed...\");17 &#125;18 19 switch (pid) &#123;20 case 0:21 write(fd,\"I`m child\",9);22 break;23 default:24 write(fd,\"I`m father\",10);25 break;26 &#125;27 return 0; 28 &#125; 05-02:123456789101112131415161718192021222324252627282930313233343536373839404142431 #include &lt;stdio.h&gt; 2 #include &lt;stdlib.h&gt; 3 #include &lt;sys/types.h&gt; 4 #include &lt;unistd.h&gt; 5 #include &lt;iostream&gt; 6 7 int main() 8 &#123; 9 10 //获取进程号11 pid_t pid = getpid();12 13 //获得父进程号14 pid_t ppid = getppid();15 16 //获取进程组号17 pid_t pgid = getpgid(pid);18 19 //输出pid,ppid,pgid20 printf(\"pid = %d | ppid = %d | pgid = %d\",pid,ppid,pgid);21 22 //创建子进程23 pid_t child_pid = fork();24 25 for (int i = 0; i &lt; 2; ++i) &#123;26 if (0 == child_pid) break;27 &#125;28 29 while (1) &#123;30 switch (child_pid) &#123;31 case -1:32 printf(\"create child process falied...\");33 break;34 case 0:35 printf(\"I`m child process:%d\",getpid());36 break;37 default:38 printf(\"I'm father process:%d\",getpid());39 break;40 &#125; 41 &#125;42 return 0;43 &#125; 05-03:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 1 #include &lt;stdio.h&gt; 2 #include &lt;unistd.h&gt; 3 #include &lt;sys/types.h&gt; 4 #include &lt;sys/wait.h&gt; 5 6 7 int main(int argc, char* argv[]) 8 &#123; 9 pid_t pid = 0;10 11 //´´½¨×Ó½ø³Ì12 for (int i = 0; i &lt; 5; ++i) &#123;13 14 pid = fork();15 if (0 == pid) &#123;16 break; 17 &#125; 18 else if (pid &lt; 0) &#123;19 return -1; 20 &#125; 21 &#125; 22 //Êä³ö½ø³Ìpid23 switch (pid) &#123;24 case 0:25 printf(\"child:%d\\n\",getpid());26 break;27 default:28 printf(\"father:%d\\n\",getpid());29 break;30 &#125; 31 //waitpid»ØÊÕ×Ó½ø³Ì32 int status = 0;33 pid_t flag = 0;34 while (1) &#123;35 flag = waitpid(-1,&amp;status,WNOHANG);36 if (-1 == flag) &#123;37 printf(\"%d:»ØÊÕ\\n\",getpid());38 return 0;39 &#125; 40 else if (0 == flag) &#123;41 continue;42 &#125; 43 else if (flag &gt; 0) &#123;44 continue;45 &#125; 46 &#125; 47 return 0;48 &#125; 05-04:123456789101112131415161718192021222324252627282930313233343536371 #include &lt;stdio.h&gt; 2 #include &lt;stdlib.h&gt; 3 #include &lt;fcntl.h&gt; 4 #include &lt;unistd.h&gt; 5 #include &lt;sys/stat.h&gt; 6 #include &lt;sys/types.h&gt; 7 8 #include &lt;iostream&gt; 9 10 int main()11 &#123;12 pid_t pid = 0;13 int time = 0;14 15 //创建子进程,此时子进程共用父进程空间16 pid = vfork();17 if (pid &lt; 0) &#123;18 printf(\"vfork failed...\");19 &#125;20 21 switch (pid) &#123;22 case 0:23 ++time;24 ++time;25 printf(\"I`m child:%d`\",getpid());26 printf(\" Value:%d`\\n\",time);27 execlp(\"ls\",\"ls\",\"-lha\",NULL);28 //exit(0); 29 break;30 31 default:32 printf(\"I`m father:%d`\",getpid());33 printf(\" Value:%d`\\n\",time);34 break;35 &#125;36 return 0;37 &#125; 06-01:1234567891011121314151617181920212223242526272829303132333435363738 1 #include &lt;stdio.h&gt; 2 #include &lt;unistd.h&gt; 3 4 int main() 5 &#123; 6 //建立pipe匿名管道用于血缘进程间的通信 7 int pipefd[2] = &#123;0&#125;; 8 pid_t pid = 0; 9 10 int pipeOk = pipe(pipefd);11 if (pipeOk == -1) &#123;12 printf(\"pipe failed...\");13 return -1;14 &#125;15 pid = fork();16 if (pid &lt; 0) &#123;17 printf(\"fork failed...\");18 return -2;19 &#125;20 21 //fork创建的子进程会把文件标识符也拷贝22 //而pipe匿名管道文件有两个文件标识符分别对应读写23 //向缓存区已满管道写入内容也会产生阻塞.24 //当读写端口都关闭时,如果向管道中写入内容.25 //会接收到系统发送的SIGPIPE信号而退出进程. 26 switch (pid) &#123;27 case 0:28 write(pipefd[1],\"I`m child process\",18);29 break;30 default:31 char buf[1024] = \"\";32 read(pipefd[0],buf,sizeof(buf));33 printf(\"[%s]\",buf);34 break;35 &#125;36 37 return 0;38 &#125; 06-02:12345678910111213141516171819202122232425262728293031323334353637 1 #include &lt;stdio.h&gt; 2 #include &lt;unistd.h&gt; 3 #include &lt;fcntl.h&gt; 4 #include &lt;sys/types.h&gt; 5 #include &lt;sys/stat.h&gt; 6 7 int main() 8 &#123; 9 pid_t pid = 0;10 int fd = 0;11 char buf[256] = \"\";12 13 //创建fifo命名管道文件 14 int mkfifoOk = mkfifo(\"./fifo\",0644);15 if (-1 == mkfifoOk) &#123;16 printf(\"mkfifo failed...\\n\");17 &#125;18 pid = fork();19 if (pid &lt; 0) &#123;20 printf(\"fork failed...\\n\");21 &#125;22 23 //通过命名管道fifo通信24 switch (pid) &#123; 25 case 0:26 fd = open(\"./fifo\", O_RDWR);27 read(fd, buf, sizeof(buf));28 printf(\"[%s]\\n\",buf);29 break;30 default:31 fd = open(\"./fifo\", O_RDWR);32 write(fd, \"oookkk\", 6);33 break;34 &#125;35 36 return 0;37 &#125; 06-03:123456789101112131415161718192021222324252627282930313233343536 1 #include &lt;stdio.h&gt; 2 #include &lt;stdlib.h&gt; 3 #include &lt;unistd.h&gt; 4 #include &lt;fcntl.h&gt; 5 #include &lt;signal.h&gt; 6 #include &lt;string.h&gt; 7 #include &lt;sys/types.h&gt; 8 #include &lt;sys/stat.h&gt; 9 #include &lt;sys/mman.h&gt;10 11 int main()12 &#123;13 //打开文件并检查是否打开成功14 int fd = open(\"./mmap.txt\",O_RDWR | O_CREAT | O_EXCL, 0666);15 if (fd &lt; 0) &#123;16 perror(\"open\");17 abort();18 &#125;19 //扩大文件大小方式映射0字节的内存空间20 int truncate_return_value = truncate(\"./mmap.txt\", 4096);21 if (truncate_return_value &lt; 0) &#123;22 perror(\"\");23 raise(9);24 &#125; 25 //映射文件26 void* ptr_mmap = mmap(NULL, 4096, PROT_WRITE | PROT_READ, MAP_SHARED, fd, 0);27 //Ê输入内容28 memcpy(ptr_mmap,\"Hello World!\",13);29 //读取内容30 printf(\"[%s]\\n\",ptr_mmap);31 //取消映射并关闭文件32 munmap(ptr_mmap,4096);33 close(fd);34 35 return 0;36 &#125; 06-04:123456789101112131415161718192021222324252627282930313233343536373839404142 1 #include &lt;stdio.h&gt; 2 #include &lt;stdlib.h&gt; 3 #include &lt;unistd.h&gt; 4 #include &lt;signal.h&gt; 5 #include &lt;sys/types.h&gt; 6 #include &lt;sys/wait.h&gt; 7 8 extern void printf_hello(int value); 9 10 int main()11 &#123;12 //创建子进程,创建失败就结束进程13 pid_t pid = vfork();14 if (pid &lt; 0) &#123;15 perror(\"\");16 abort();17 &#125;18 19 //子进程启动程序20 if (pid == 0) &#123;21 execl(\"./day06_03_mmap.out\", \"./day06_03_mmap.out\");22 &#125;23 24 //父进程改写1号信号并给自己发送1号信号25 else &#123;26 signal(1, printf_hello);27 kill(0,1);28 sleep(3);29 raise(9);30 pid = waitpid(pid, NULL, WNOHANG);31 if (pid &lt; 0) &#123;32 printf(\"wait end...\\n\");33 return 0;34 &#125;35 &#125;36 37 return 0;38 &#125;39 40 void printf_hello(int value) &#123;41 printf(\"hello\\n\");42 &#125; 06-05:123456789101112131415161718192021222324252627282930313233343536373839404142 1 #include &lt;signal.h&gt; 2 #include &lt;stdio.h&gt; 3 #include &lt;unistd.h&gt; 4 5 extern void printf_hello(int); 6 7 int main() 8 &#123; 9 10 sigset_t my_sigset;11 sigfillset(&amp;my_sigset); //将所有信号添加到信号集 12 sigemptyset(&amp;my_sigset); //清空信号集13 14 sigdelset(&amp;my_sigset,10); //删除信号集里的信号15 sigaddset(&amp;my_sigset,2); //向信号集添加信号16 sigismember(&amp;my_sigset,2);//判断信号是不是信号集成员17 struct sigaction act = &#123;printf_hello, 0, 0&#125;;18 sigaction(1, &amp;act, NULL); //改变信号操作内容19 sigprocmask(SIG_BLOCK,&amp;my_sigset,NULL);//将信号集设置为阻塞集20 while (1) &#123;21 sigpending(&amp;my_sigset);22 for (size_t i = 1; i &lt; 32; ++i) &#123;23 if (sigismember(&amp;my_sigset,i)) &#123;24 printf(\"1\");25 &#125;26 else &#123;27 printf(\"0\");28 &#125;29 &#125;30 printf(\"\\n\");31 kill(0,1);32 sleep(1);33 &#125;34 printf(\"\\n\");35 36 return 0;37 &#125;38 39 40 void printf_hello(int value = 0) &#123;41 printf(\"hello\\n\");42 &#125; 06-06:1234567891011121314151617181920212223242526272829303132333435363738394041424344 1 #include &lt;stdio.h&gt; 2 #include &lt;unistd.h&gt; 3 #include &lt;signal.h&gt; 4 //创建守护进程 5 int main() 6 &#123; 7 pid_t pid; 8 pid = fork(); 9 if (pid &lt; -1) &#123;10 perror(\"\");11 &#125;12 13 switch (pid) &#123;14 case 0:15 printf(\"I`m child,i will exit\\n\");16 sleep(10); //第二步,setsid()脱离终端控制17 pid = setsid();18 if (pid &lt; 0) &#123;19 perror(\"\");20 &#125;21 else &#123; //第三步,改变工作路径22 chdir(\"~\"); //第四步,设置掩码阻塞集23 sigset_t my_sigset;24 sigfillset(&amp;my_sigset);25 sigprocmask(SIG_BLOCK, &amp;my_sigset, NULL); //第五步,关闭没有用的文件描述符26 close(STDIN_FILENO);27 close(STDOUT_FILENO);28 close(STDERR_FILENO)29 execl(\"./a.out\",\"./a.out\"); //第六步,运行守护进程内容 30 &#125;31 break;32 //第一步,创建孤儿进程33 default:34 printf(\"I`m father,i will exit\\n\");35 break;36 &#125;37 38 39 return 0;40 &#125; 07-01:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 1 #include &lt;stdio.h&gt; 2 #include &lt;stdlib.h&gt; 3 #include &lt;unistd.h&gt; 4 #include &lt;stdint.h&gt; 5 #include &lt;pthread.h&gt; 6 #include &lt;semaphore.h&gt; 7 8 #include &lt;iostream&gt; 9 10 extern void* consumer(void* arg);11 extern void* product(void* arg);12 13 namespace &#123;14 int32_t number = 0; //创建信号量15 sem_t sem_product;16 sem_t sem_consumer;17 18 &#125;19 20 int main()21 &#123;22 printf(\"main function strat...\\n\");23 //初始化信号量24 sem_init(&amp;sem_consumer, 0, 0);25 sem_init(&amp;sem_product, 0, 10); 26 pthread_t pthread[10];27 //创建三个消费者子线程28 for (uint64_t i = 0; i &lt; 10; ++i) &#123; //创建3个子线程29 int create_successed = pthread_create(&amp;(pthread[i]),30 NULL,31 consumer,32 reinterpret_cast&lt;void*&gt;(i));33 if (0 != create_successed) &#123;34 perror(\"pthread_create\\n\");35 &#125;36 else &#123; //设置线程分离属性,由系统自动回收资源37 int join_successed = pthread_detach(pthread[i]);38 if (0 != join_successed) &#123;39 perror(\"pthread_join\\n\");40 &#125;41 &#125;42 &#125;43 //创建生产者 44 pthread_t product_pthread_id;45 int create_successed = pthread_create(&amp;product_pthread_id,46 NULL,47 product,48 NULL);49 if (0 != create_successed) &#123;50 perror(\"pthread_create\\n\");51 &#125;52 else &#123;53 int join_successed = pthread_detach(product_pthread_id);54 if (0 != join_successed) &#123;55 perror(\"pthread_join\\n\");56 &#125;57 &#125;58 59 printf(\"main function waiting...\\n\");60 while (1) &#123;61 continue;62 &#125;63 return 0;64 &#125;65 //生产者66 void* product(void* arg) &#123;67 while (1) &#123;68 if (number &gt; -1 &amp;&amp; number &lt; 10) &#123;69 sem_wait(&amp;sem_product); 70 printf(\"product: %u\\n\",++number);71 sem_post(&amp;sem_consumer);72 &#125;73 &#125;74 &#125;75 //消费者76 void* consumer (void* arg) &#123;77 while(1) &#123;78 if (number &gt; 0) &#123;79 sem_wait(&amp;sem_consumer);80 printf(\"consumer %u: %d\\n\", reinterpret_cast&lt;uint64_t&gt;(arg), --number);81 sem_post(&amp;sem_product);82 &#125;83 sleep(2);84 &#125;85 &#125;","categories":[],"tags":[]},{"title":"线程池","slug":"线程池","date":"2019-06-20T01:27:54.000Z","updated":"2019-06-20T01:45:25.964Z","comments":true,"path":"2019/06/20/线程池/","link":"","permalink":"http://yoursite.com/2019/06/20/线程池/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"epoll 多路IO复用","slug":"epoll","date":"2019-06-19T06:46:12.000Z","updated":"2019-06-20T02:58:38.056Z","comments":true,"path":"2019/06/19/epoll/","link":"","permalink":"http://yoursite.com/2019/06/19/epoll/","excerpt":"","text":"#include &lt;stdio.h&gt; #include &lt;sys/epoll.h&gt; #include “wrap.h” #include &lt;fcntl.h&gt; #define EPOLL_SIZE 1024int main(int argc, char *argv[]){ if(argc &lt; 2) { printf(“argc &lt;2 : ./a.out port \\n”); return 0; } // 创建套接字 int lfd = tcp4bind( atoi(argv[1]),NULL ); // 绑定 // 监听 Listen(lfd,128); // 创建树 int epfd = epoll_create(1); // 将lfd上树监听 struct epoll_event ev,evs[EPOLL_SIZE]; ev.data.fd = lfd; ev.events = EPOLLIN; epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev); // while循环监听树的文件描述符 while(1) { //监听文件描述符的属性变化 int n = epoll_wait(epfd,evs,EPOLL_SIZE,-1); printf(&quot;-----------epoll_wait-----------\\n&quot;); if(n &lt; 0) { perror(&quot;&quot;); break; } else if( n &gt;= 0 ) { for(int i=0;i&lt;n;i++) { int fd = evs[i].data.fd; //如果是lfd变化,并且是读事件变化 if(fd == lfd &amp;&amp; evs[i].events &amp; EPOLLIN ) { struct sockaddr_in cliaddr; socklen_t len = sizeof(cliaddr); char ip[INET_ADDRSTRLEN]=&quot;&quot;; // 提取新的连接 int cfd = Accept(lfd,(struct sockaddr*)&amp;cliaddr,&amp;len); printf(&quot;client ip=%s port=%d\\n&quot;,inet_ntop(AF_INET,&amp;cliaddr.sin_addr.s_addr,ip,INET_ADDRSTRLEN), ntohs(cliaddr.sin_port)); //设置cfd的阻塞特性为非阻塞 int flag = fcntl(cfd,F_GETFL); flag |= O_NONBLOCK; fcntl(cfd,F_SETFL,flag); // 将cfd上树 ev.data.fd = cfd; ev.events = EPOLLIN | EPOLLET; //上树 epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev); } else if( evs[i].events &amp; EPOLLIN )//一定是cfd变化,在确认一下是不是cfd的读事件变化了 { while(1) { // cfd的读事件变化 读取客户端发过来的消息 char buf[4]=&quot;&quot;; int count = Read(fd, buf,sizeof(buf));//阻塞 //如果read读的缓冲区没有数据,read的返回值是-1 errno的值会被设置成EAGAIN if(count &lt; 0) { if(errno == EAGAIN) { break; } //出错 下树 perror(&quot;&quot;); close(fd); epoll_ctl(epfd,EPOLL_CTL_DEL,fd,&amp;evs[i]); break; } else if(count == 0) { //客户端关闭, 下树 printf(&quot;client close\\n&quot;); close(fd); epoll_ctl(epfd,EPOLL_CTL_DEL,fd,&amp;evs[i]); break; } else { write(STDOUT_FILENO,buf,count); Write(fd,buf,count); } } } } } } return 0;}","categories":[],"tags":[]},{"title":"My_hexo_blog","slug":"My-hexo-blog","date":"2019-06-19T02:58:41.000Z","updated":"2019-06-19T03:10:52.089Z","comments":true,"path":"2019/06/19/My-hexo-blog/","link":"","permalink":"http://yoursite.com/2019/06/19/My-hexo-blog/","excerpt":"","text":"##第一篇 —内容— ##第二篇 —内容— ##第三篇 —内容—","categories":[],"tags":[]}]}