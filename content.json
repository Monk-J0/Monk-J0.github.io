{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"web-server","date":"2019-06-24T12:58:08.154Z","updated":"2019-06-24T12:58:08.154Z","comments":true,"path":"2019/06/24/web-server/","link":"","permalink":"http://yoursite.com/2019/06/24/web-server/","excerpt":"","text":"#include &lt;stdio.h&gt; #include &lt;sys/epoll.h&gt; #include “wrap.h” #include &lt;fcntl.h&gt; #include &lt;dirent.h&gt; #include “pub.h” #include &lt;signal.h&gt; #include &lt;sys/stat.h&gt; #define PORT 8888 #define EPOLL_SIZE 1024void send_header(int cfd ,int code,char *info,char *filetype,int length){ char buf[1024]=””; //发送状态行 int len = sprintf(buf,”HTTP/1.1 %d %s\\r\\n”,code,info); send(cfd,buf,len,0); //状态信息 文件类型 len = sprintf(buf,”Content-Type:%s\\r\\n”,filetype); send(cfd,buf,len,0); //文件大小 if(length &gt; 0) { len = sprintf(buf,”Content-Length:%d\\r\\n”,length); send(cfd,buf,len,0); } //空行 send(cfd,”\\r\\n”,2,0); } void send_file(int cfd, struct epoll_event *ev,char *pathname,int flag,int epfd){ int fd = open(pathname,O_RDWR); if(fd &lt; 0) { perror(“”); return ; } while(1) { char buf[1024]=””; int n = read(fd,buf,sizeof(buf)); if(n &lt;=0) break; int count = send(cfd,buf,n,0); printf(&quot;count =%d\\n&quot;,count); } close(fd); if(flag == 1) { close(cfd); epoll_ctl(epfd,EPOLL_CTL_DEL,cfd,ev); }} void client_request(struct epoll_event *ev,int epfd){ int cfd = ev-&gt;data.fd; char buf[1024]=””; char tmp[1024]=””; int n = Readline(cfd,buf,sizeof(buf)); if(n &lt;= 0) { close(cfd); epoll_ctl(epfd,EPOLL_CTL_DEL,cfd,ev); } // printf(“buf=[%s]\\n”,buf); //将缓冲读干净 while( (n=Readline(cfd,tmp,sizeof(tmp))) &gt; 0); //GET / HTTP1.1\\R\\N char mothod[256],content[256]; sscanf(buf,”%[^ ] %[^ ]”,mothod,content); printf(“[%s] [%s]\\n”,mothod,content); //如果是get请求处理 if( strcasecmp(mothod,”get”) == 0) { // %e8%b8%…txt char strfile = content+1; strdecode( strfile,strfile); if(strfile == 0) strfile = “./“;//如果没有请求文件,默认请求当前目录 //判断请求的文件是否存在 struct stat s; int ret = stat(strfile,&amp;s); if(ret &lt; 0)//文件不存在 { //发送信息头 //void send_header(int cfd ,int code,char info,char *filetype,int length) send_header(cfd,404,”NOT FOUND”,get_mime_type(“.html”),0); //void send_file(int cfd, struct epoll_event *ev,char *pathname,int flag,int epfd) //发送error.html send_file(cfd,ev,”error.html”,1,epfd); } else//文件存在 { //如果是一个常规文件 if(S_ISREG(s.st_mode)) { //发送信息头 send_header(cfd,200,&quot;OK&quot;,get_mime_type(strfile),s.st_size); //发送文件内容 send_file(cfd,ev,strfile,1,epfd); } else if(S_ISDIR(s.st_mode))//如果是一个目录 { //发送信息头 send_header(cfd,200,&quot;OK&quot;,get_mime_type(&quot;*.html&quot;),0); //发送dir_header.html send_file(cfd,ev,&quot;dir_header.html&quot;,0,epfd); //发送列表 //先要得到 目录下的文件名 struct dirent **list; int size = scandir(strfile,&amp;list,NULL,alphasort); for(int i=0;i&lt;size;i++) { // list[i]-&gt;d_name char buff[256]=&quot;&quot;; int len =0; if( list[i]-&gt;d_type == DT_DIR) { len = sprintf(buff,&quot;&lt;li&gt;&lt;a href=%s/&gt;%s&lt;a&gt;&lt;/li&gt;&quot;,list[i]-&gt;d_name,list[i]-&gt;d_name); } else { len = sprintf(buff,&quot;&lt;li&gt;&lt;a href=%s&gt;%s&lt;a&gt;&lt;/li&gt;&quot;,list[i]-&gt;d_name,list[i]-&gt;d_name); } send(cfd,buff,len,0); free(list[i]); } free(list); //发送dir_tail.html send_file(cfd,ev,&quot;dir_tail.html&quot;,1,epfd); } } } else { //其他请求 暂时不处理 close(cfd); epoll_ctl(epfd,EPOLL_CTL_DEL,cfd,ev); }} int main(int argc, char argv[]){ signal(SIGPIPE,SIG_IGN); //切换工作路径 char path[256]=””; char *pwd = getenv(“PWD”); ///home/itheima/share/shangc++01/1617day strcpy(path,pwd); strcat(path,”/web-http”); chdir(path); //创建套接字 绑定 int lfd = tcp4bind(PORT,NULL); //监听 Listen(lfd,128); //创建树 int epfd = epoll_create(1); //lfd上树 struct epoll_event ev,evs[EPOLL_SIZE]; ev.data.fd = lfd; ev.events = EPOLLIN; epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev); //循环监听 while(1) { int n = epoll_wait(epfd,evs,EPOLL_SIZE,-1); if(n &lt; 0) { perror(“”); break; } else { for(int i=0;i&lt;n;i++) { // lfd变化 if(evs[i].data.fd == lfd &amp;&amp; evs[i].events &amp; EPOLLIN) { struct sockaddr_in cliaddr; char ip[INET_ADDRSTRLEN]=””; socklen_t len = sizeof(cliaddr); //提取链接 int cfd = Accept(lfd,(struct sockaddr)&amp;cliaddr,&amp;len); printf(“client ip=%s port=%d\\n”, inet_ntop(AF_INET,&amp;cliaddr.sin_addr.s_addr,ip,INET_ADDRSTRLEN), ntohs(cliaddr.sin_port)); //cfd设置为非阻塞 int flag = fcntl(cfd,F_GETFL); flag |= O_NONBLOCK; fcntl(cfd,F_SETFL,flag); //cfd上树监听 ev.data.fd = cfd; ev.events = EPOLLIN; epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev); } else if( evs[i].events &amp; EPOLLIN)//cfd变化 { client_request(&amp;evs[i],epfd); } } } } //收尾 return 0;}","categories":[],"tags":[]},{"title":"","slug":"http_server","date":"2019-06-24T12:55:47.952Z","updated":"2019-06-24T12:55:47.940Z","comments":true,"path":"2019/06/24/http_server/","link":"","permalink":"http://yoursite.com/2019/06/24/http_server/","excerpt":"","text":"#include &lt;stdio.h&gt; #include &lt;sys/epoll.h&gt; #include “wrap.h” #include &lt;fcntl.h&gt; #include &lt;dirent.h&gt; #include “pub.h” #include &lt;signal.h&gt; #include &lt;sys/stat.h&gt; #define PORT 8888 #define EPOLL_SIZE 1024void send_header(int cfd ,int code,char *info,char *filetype,int length){ char buf[1024]=””; //发送状态行 int len = sprintf(buf,”HTTP/1.1 %d %s\\r\\n”,code,info); send(cfd,buf,len,0); //状态信息 文件类型 len = sprintf(buf,”Content-Type:%s\\r\\n”,filetype); send(cfd,buf,len,0); //文件大小 if(length &gt; 0) { len = sprintf(buf,”Content-Length:%d\\r\\n”,length); send(cfd,buf,len,0); } //空行 send(cfd,”\\r\\n”,2,0); } void send_file(int cfd, struct epoll_event *ev,char *pathname,int flag,int epfd){ int fd = open(pathname,O_RDWR); if(fd &lt; 0) { perror(“”); return ; } while(1) { char buf[1024]=””; int n = read(fd,buf,sizeof(buf)); if(n &lt;=0) break; int count = send(cfd,buf,n,0); printf(&quot;count =%d\\n&quot;,count); } close(fd); if(flag == 1) { close(cfd); epoll_ctl(epfd,EPOLL_CTL_DEL,cfd,ev); }} void client_request(struct epoll_event *ev,int epfd){ int cfd = ev-&gt;data.fd; char buf[1024]=””; char tmp[1024]=””; int n = Readline(cfd,buf,sizeof(buf)); if(n &lt;= 0) { close(cfd); epoll_ctl(epfd,EPOLL_CTL_DEL,cfd,ev); } // printf(“buf=[%s]\\n”,buf); //将缓冲读干净 while( (n=Readline(cfd,tmp,sizeof(tmp))) &gt; 0); //GET / HTTP1.1\\R\\N char mothod[256],content[256]; sscanf(buf,”%[^ ] %[^ ]”,mothod,content); printf(“[%s] [%s]\\n”,mothod,content); //如果是get请求处理 if( strcasecmp(mothod,”get”) == 0) { // %e8%b8%…txt char strfile = content+1; strdecode( strfile,strfile); if(strfile == 0) strfile = “./“;//如果没有请求文件,默认请求当前目录 //判断请求的文件是否存在 struct stat s; int ret = stat(strfile,&amp;s); if(ret &lt; 0)//文件不存在 { //发送信息头 //void send_header(int cfd ,int code,char info,char *filetype,int length) send_header(cfd,404,”NOT FOUND”,get_mime_type(“.html”),0); //void send_file(int cfd, struct epoll_event *ev,char *pathname,int flag,int epfd) //发送error.html send_file(cfd,ev,”error.html”,1,epfd); } else//文件存在 { //如果是一个常规文件 if(S_ISREG(s.st_mode)) { //发送信息头 send_header(cfd,200,&quot;OK&quot;,get_mime_type(strfile),s.st_size); //发送文件内容 send_file(cfd,ev,strfile,1,epfd); } else if(S_ISDIR(s.st_mode))//如果是一个目录 { //发送信息头 send_header(cfd,200,&quot;OK&quot;,get_mime_type(&quot;*.html&quot;),0); //发送dir_header.html send_file(cfd,ev,&quot;dir_header.html&quot;,0,epfd); //发送列表 //先要得到 目录下的文件名 struct dirent **list; int size = scandir(strfile,&amp;list,NULL,alphasort); for(int i=0;i&lt;size;i++) { // list[i]-&gt;d_name char buff[256]=&quot;&quot;; int len =0; if( list[i]-&gt;d_type == DT_DIR) { len = sprintf(buff,&quot;&lt;li&gt;&lt;a href=%s/&gt;%s&lt;a&gt;&lt;/li&gt;&quot;,list[i]-&gt;d_name,list[i]-&gt;d_name); } else { len = sprintf(buff,&quot;&lt;li&gt;&lt;a href=%s&gt;%s&lt;a&gt;&lt;/li&gt;&quot;,list[i]-&gt;d_name,list[i]-&gt;d_name); } send(cfd,buff,len,0); free(list[i]); } free(list); //发送dir_tail.html send_file(cfd,ev,&quot;dir_tail.html&quot;,1,epfd); } } } else { //其他请求 暂时不处理 close(cfd); epoll_ctl(epfd,EPOLL_CTL_DEL,cfd,ev); }} int main(int argc, char argv[]){ signal(SIGPIPE,SIG_IGN); //切换工作路径 char path[256]=””; char *pwd = getenv(“PWD”); ///home/itheima/share/shangc++01/1617day strcpy(path,pwd); strcat(path,”/web-http”); chdir(path); //创建套接字 绑定 int lfd = tcp4bind(PORT,NULL); //监听 Listen(lfd,128); //创建树 int epfd = epoll_create(1); //lfd上树 struct epoll_event ev,evs[EPOLL_SIZE]; ev.data.fd = lfd; ev.events = EPOLLIN; epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev); //循环监听 while(1) { int n = epoll_wait(epfd,evs,EPOLL_SIZE,-1); if(n &lt; 0) { perror(“”); break; } else { for(int i=0;i&lt;n;i++) { // lfd变化 if(evs[i].data.fd == lfd &amp;&amp; evs[i].events &amp; EPOLLIN) { struct sockaddr_in cliaddr; char ip[INET_ADDRSTRLEN]=””; socklen_t len = sizeof(cliaddr); //提取链接 int cfd = Accept(lfd,(struct sockaddr)&amp;cliaddr,&amp;len); printf(“client ip=%s port=%d\\n”, inet_ntop(AF_INET,&amp;cliaddr.sin_addr.s_addr,ip,INET_ADDRSTRLEN), ntohs(cliaddr.sin_port)); //cfd设置为非阻塞 int flag = fcntl(cfd,F_GETFL); flag |= O_NONBLOCK; fcntl(cfd,F_SETFL,flag); //cfd上树监听 ev.data.fd = cfd; ev.events = EPOLLIN; epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev); } else if( evs[i].events &amp; EPOLLIN)//cfd变化 { client_request(&amp;evs[i],epfd); } } } } //收尾 return 0;}","categories":[],"tags":[]},{"title":"Tcp三次握手","slug":"Tcp三次握手","date":"2019-06-21T12:06:10.000Z","updated":"2019-06-21T12:06:52.344Z","comments":true,"path":"2019/06/21/Tcp三次握手/","link":"","permalink":"http://yoursite.com/2019/06/21/Tcp三次握手/","excerpt":"","text":"1、 服务器调用socket()、bind()、listen()完成初始化后，调用accept()阻塞等待，处于监听端口的状态，客户端调用socket()初始化后，调用connect()发出SYN段并阻塞 等待服务器应答，服务器应答一个SYN-ACK段，客户端收到后从connect()返回，同时应 答一个ACK段，服务器收到后从accept()返回。 2、三次握手Three-way Handshake （建立一个TCP连接） 一个虚拟连接的建立是通过三次握手来实现的 2.1. (B) –&gt; [SYN] –&gt; (A) 假如服务器A和客户机B通讯. 当A要和B通信时，B首先向A发一个SYN (Synchronize) 标记的包，告诉A请求建立连接. 注意: 一个 SYN包就是仅SYN标记设为1的TCP包(参见TCP包头Resources). 认识 到这点很重要，只有当A受到B发来的SYN包，才可建立连接，除此之外别无他法。因此， 如果你的防火墙丢弃所有的发往外网接口的SYN包，那么你将不能让外部任何主机主动建立连接。 2.2. (B) &lt;– [SYN/ACK] &lt;–(A) 接着，A收到后会发一个对SYN包的确认包(SYN/ACK)回去，表示对第一个SYN包的确 认，并继续握手操作. 注意: SYN/ACK包是仅SYN 和 ACK 标记为1的包. 2.3. (B) –&gt; [ACK] –&gt; (A) B收到SYN/ACK 包,B发一个确认包(ACK)，通知A连接已建立。至此，三次握手完成， 一个TCP连接完成 Note: ACK包就是仅ACK 标记设为1的TCP包. 需要注意的是当三此握手完成、连接建 立以后，TCP连接的每个包都会设置ACK位 这就是为何连接跟踪很重要的原因了. 没有连接跟踪,防火 墙将无法判断收到的ACK包是否属于一个已经建立的连接.一般的包过滤(Ipchains)收到ACK包时,会让它通过(这绝对不 是个好主意).而当状态型防火墙收到此种包时，它会先在连接表中查找是否属于哪个已经连接，否则丢弃该包. 补充知识点： TCP报文中的序列号（32 位 一个包的序号，且称为seq）和确认号（32位 确认对方发给我的数据包的确认号，且称为ack） （确认号的两层含义(承上启下)1、确认收到上一次（对方）发送给我的数据；2、期待对方下一次报文中的序列号 为我的确认号。Ack = 对方（上一次）发送的报文序列号 + SYN 标志位的长度 + 数据长度） 第一次发送数据包时，即(B) --&gt; [SYN] --&gt; (A) 时seq = &quot;随机整数值X&quot;；ack没有其他进程发包给自己所以ack=0; 第二次发送数据包时（即 (B) &lt;-- [SYN/ACK] &lt;--(A) ）；seq = &quot;随机整数值Y&quot;；ack = X+1+0; 第三次发送数据包时（即(B) --&gt; [ACK] --&gt; (A)）；seq = X+1+0;(即上一次报文的确认号)；ack = Y+1+0;(即上一次报文中的序列号+SYN标志位长度+数据长度)","categories":[],"tags":[]},{"title":"epoll 多路IO复用","slug":"epoll","date":"2019-06-19T06:46:12.000Z","updated":"2019-06-20T02:58:38.056Z","comments":true,"path":"2019/06/19/epoll/","link":"","permalink":"http://yoursite.com/2019/06/19/epoll/","excerpt":"","text":"#include &lt;stdio.h&gt; #include &lt;sys/epoll.h&gt; #include “wrap.h” #include &lt;fcntl.h&gt; #define EPOLL_SIZE 1024int main(int argc, char *argv[]){ if(argc &lt; 2) { printf(“argc &lt;2 : ./a.out port \\n”); return 0; } // 创建套接字 int lfd = tcp4bind( atoi(argv[1]),NULL ); // 绑定 // 监听 Listen(lfd,128); // 创建树 int epfd = epoll_create(1); // 将lfd上树监听 struct epoll_event ev,evs[EPOLL_SIZE]; ev.data.fd = lfd; ev.events = EPOLLIN; epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev); // while循环监听树的文件描述符 while(1) { //监听文件描述符的属性变化 int n = epoll_wait(epfd,evs,EPOLL_SIZE,-1); printf(&quot;-----------epoll_wait-----------\\n&quot;); if(n &lt; 0) { perror(&quot;&quot;); break; } else if( n &gt;= 0 ) { for(int i=0;i&lt;n;i++) { int fd = evs[i].data.fd; //如果是lfd变化,并且是读事件变化 if(fd == lfd &amp;&amp; evs[i].events &amp; EPOLLIN ) { struct sockaddr_in cliaddr; socklen_t len = sizeof(cliaddr); char ip[INET_ADDRSTRLEN]=&quot;&quot;; // 提取新的连接 int cfd = Accept(lfd,(struct sockaddr*)&amp;cliaddr,&amp;len); printf(&quot;client ip=%s port=%d\\n&quot;,inet_ntop(AF_INET,&amp;cliaddr.sin_addr.s_addr,ip,INET_ADDRSTRLEN), ntohs(cliaddr.sin_port)); //设置cfd的阻塞特性为非阻塞 int flag = fcntl(cfd,F_GETFL); flag |= O_NONBLOCK; fcntl(cfd,F_SETFL,flag); // 将cfd上树 ev.data.fd = cfd; ev.events = EPOLLIN | EPOLLET; //上树 epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev); } else if( evs[i].events &amp; EPOLLIN )//一定是cfd变化,在确认一下是不是cfd的读事件变化了 { while(1) { // cfd的读事件变化 读取客户端发过来的消息 char buf[4]=&quot;&quot;; int count = Read(fd, buf,sizeof(buf));//阻塞 //如果read读的缓冲区没有数据,read的返回值是-1 errno的值会被设置成EAGAIN if(count &lt; 0) { if(errno == EAGAIN) { break; } //出错 下树 perror(&quot;&quot;); close(fd); epoll_ctl(epfd,EPOLL_CTL_DEL,fd,&amp;evs[i]); break; } else if(count == 0) { //客户端关闭, 下树 printf(&quot;client close\\n&quot;); close(fd); epoll_ctl(epfd,EPOLL_CTL_DEL,fd,&amp;evs[i]); break; } else { write(STDOUT_FILENO,buf,count); Write(fd,buf,count); } } } } } } return 0;}","categories":[],"tags":[]}]}