{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"tcp三次握手","slug":"tcp三次握手","date":"2019-06-21T11:59:32.000Z","updated":"2019-06-21T12:00:48.308Z","comments":true,"path":"2019/06/21/tcp三次握手/","link":"","permalink":"http://yoursite.com/2019/06/21/tcp三次握手/","excerpt":"","text":"1、 服务器调用socket()、bind()、listen()完成初始化后，调用accept()阻塞等待，处于监听端口的状态，客户端调用socket()初始化后，调用connect()发出SYN段并阻塞 等待服务器应答，服务器应答一个SYN-ACK段，客户端收到后从connect()返回，同时应 答一个ACK段，服务器收到后从accept()返回。 2、三次握手Three-way Handshake （建立一个TCP连接） 一个虚拟连接的建立是通过三次握手来实现的 (B) –&gt; [SYN] –&gt; (A) 假如服务器A和客户机B通讯. 当A要和B通信时，B首先向A发一个SYN (Synchronize) 标记的包，告诉A请求建立连接. 注意: 一个 SYN包就是仅SYN标记设为1的TCP包(参见TCP包头Resources). 认识 到这点很重要，只有当A受到B发来的SYN包，才可建立连接，除此之外别无他法。因此， 如果你的防火墙丢弃所有的发往外网接口的SYN包，那么你将不能让外部任何主机主动建立连接。 (B) &lt;– [SYN/ACK] &lt;–(A) 接着，A收到后会发一个对SYN包的确认包(SYN/ACK)回去，表示对第一个SYN包的确 认，并继续握手操作. 注意: SYN/ACK包是仅SYN 和 ACK 标记为1的包. (B) –&gt; [ACK] –&gt; (A) B收到SYN/ACK 包,B发一个确认包(ACK)，通知A连接已建立。至此，三次握手完成， 一个TCP连接完成 Note: ACK包就是仅ACK 标记设为1的TCP包. 需要注意的是当三此握手完成、连接建 立以后，TCP连接的每个包都会设置ACK位 这就是为何连接跟踪很重要的原因了. 没有连接跟踪,防火 墙将无法判断收到的ACK包是否属于一个已经建立的连接.一般的包过滤(Ipchains)收到ACK包时,会让它通过(这绝对不 是个好主意). 而当状态型防火墙收到此种包时，它会先在连接表中查找是否属于哪个已建连接，否则丢弃该包 补充知识点： TCP报文中的序列号（32 位 一个包的序号，且称为seq）和确认号（32位 确认对方发给我的数据包的确认号，且称为ack） （确认号的两层含义(承上启下)1、确认收到上一次（对方）发送给我的数据；2、期待对方下一次报文中的序列号 为我的确认号。Ack = 对方（上一次）发送的报文序列号 + SYN 标志位的长度 + 数据长度） 第一次发送数据包时，即(B) –&gt; [SYN] –&gt; (A) 时seq = “随机整数值X”；ack没有其他进程发包给自己所以ack=0; 第二次发送数据包时（即 (B) &lt;– [SYN/ACK] &lt;–(A) ）；seq = “随机整数值Y”；ack = X+1+0; 第三次发送数据包时（即(B) –&gt; [ACK] –&gt; (A)）；seq = X+1+0;(即上一次报文的确认号)；ack = Y+1+0;(即上一次报文中的序列号+SYN标志位长度+数据长度)","categories":[],"tags":[]},{"title":"epoll 多路IO复用","slug":"epoll","date":"2019-06-19T06:46:12.000Z","updated":"2019-06-20T02:58:38.056Z","comments":true,"path":"2019/06/19/epoll/","link":"","permalink":"http://yoursite.com/2019/06/19/epoll/","excerpt":"","text":"#include &lt;stdio.h&gt; #include &lt;sys/epoll.h&gt; #include “wrap.h” #include &lt;fcntl.h&gt; #define EPOLL_SIZE 1024int main(int argc, char *argv[]){ if(argc &lt; 2) { printf(“argc &lt;2 : ./a.out port \\n”); return 0; } // 创建套接字 int lfd = tcp4bind( atoi(argv[1]),NULL ); // 绑定 // 监听 Listen(lfd,128); // 创建树 int epfd = epoll_create(1); // 将lfd上树监听 struct epoll_event ev,evs[EPOLL_SIZE]; ev.data.fd = lfd; ev.events = EPOLLIN; epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev); // while循环监听树的文件描述符 while(1) { //监听文件描述符的属性变化 int n = epoll_wait(epfd,evs,EPOLL_SIZE,-1); printf(&quot;-----------epoll_wait-----------\\n&quot;); if(n &lt; 0) { perror(&quot;&quot;); break; } else if( n &gt;= 0 ) { for(int i=0;i&lt;n;i++) { int fd = evs[i].data.fd; //如果是lfd变化,并且是读事件变化 if(fd == lfd &amp;&amp; evs[i].events &amp; EPOLLIN ) { struct sockaddr_in cliaddr; socklen_t len = sizeof(cliaddr); char ip[INET_ADDRSTRLEN]=&quot;&quot;; // 提取新的连接 int cfd = Accept(lfd,(struct sockaddr*)&amp;cliaddr,&amp;len); printf(&quot;client ip=%s port=%d\\n&quot;,inet_ntop(AF_INET,&amp;cliaddr.sin_addr.s_addr,ip,INET_ADDRSTRLEN), ntohs(cliaddr.sin_port)); //设置cfd的阻塞特性为非阻塞 int flag = fcntl(cfd,F_GETFL); flag |= O_NONBLOCK; fcntl(cfd,F_SETFL,flag); // 将cfd上树 ev.data.fd = cfd; ev.events = EPOLLIN | EPOLLET; //上树 epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev); } else if( evs[i].events &amp; EPOLLIN )//一定是cfd变化,在确认一下是不是cfd的读事件变化了 { while(1) { // cfd的读事件变化 读取客户端发过来的消息 char buf[4]=&quot;&quot;; int count = Read(fd, buf,sizeof(buf));//阻塞 //如果read读的缓冲区没有数据,read的返回值是-1 errno的值会被设置成EAGAIN if(count &lt; 0) { if(errno == EAGAIN) { break; } //出错 下树 perror(&quot;&quot;); close(fd); epoll_ctl(epfd,EPOLL_CTL_DEL,fd,&amp;evs[i]); break; } else if(count == 0) { //客户端关闭, 下树 printf(&quot;client close\\n&quot;); close(fd); epoll_ctl(epfd,EPOLL_CTL_DEL,fd,&amp;evs[i]); break; } else { write(STDOUT_FILENO,buf,count); Write(fd,buf,count); } } } } } } return 0;}","categories":[],"tags":[]}]}