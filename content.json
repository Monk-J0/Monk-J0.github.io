{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"线程池","slug":"线程池","date":"2019-06-20T01:27:54.000Z","updated":"2019-06-20T01:45:25.964Z","comments":true,"path":"2019/06/20/线程池/","link":"","permalink":"http://yoursite.com/2019/06/20/线程池/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"epoll 多路IO复用","slug":"epoll","date":"2019-06-19T06:46:12.000Z","updated":"2019-06-20T02:58:38.056Z","comments":true,"path":"2019/06/19/epoll/","link":"","permalink":"http://yoursite.com/2019/06/19/epoll/","excerpt":"","text":"#include &lt;stdio.h&gt; #include &lt;sys/epoll.h&gt; #include “wrap.h” #include &lt;fcntl.h&gt; #define EPOLL_SIZE 1024int main(int argc, char *argv[]){ if(argc &lt; 2) { printf(“argc &lt;2 : ./a.out port \\n”); return 0; } // 创建套接字 int lfd = tcp4bind( atoi(argv[1]),NULL ); // 绑定 // 监听 Listen(lfd,128); // 创建树 int epfd = epoll_create(1); // 将lfd上树监听 struct epoll_event ev,evs[EPOLL_SIZE]; ev.data.fd = lfd; ev.events = EPOLLIN; epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;ev); // while循环监听树的文件描述符 while(1) { //监听文件描述符的属性变化 int n = epoll_wait(epfd,evs,EPOLL_SIZE,-1); printf(&quot;-----------epoll_wait-----------\\n&quot;); if(n &lt; 0) { perror(&quot;&quot;); break; } else if( n &gt;= 0 ) { for(int i=0;i&lt;n;i++) { int fd = evs[i].data.fd; //如果是lfd变化,并且是读事件变化 if(fd == lfd &amp;&amp; evs[i].events &amp; EPOLLIN ) { struct sockaddr_in cliaddr; socklen_t len = sizeof(cliaddr); char ip[INET_ADDRSTRLEN]=&quot;&quot;; // 提取新的连接 int cfd = Accept(lfd,(struct sockaddr*)&amp;cliaddr,&amp;len); printf(&quot;client ip=%s port=%d\\n&quot;,inet_ntop(AF_INET,&amp;cliaddr.sin_addr.s_addr,ip,INET_ADDRSTRLEN), ntohs(cliaddr.sin_port)); //设置cfd的阻塞特性为非阻塞 int flag = fcntl(cfd,F_GETFL); flag |= O_NONBLOCK; fcntl(cfd,F_SETFL,flag); // 将cfd上树 ev.data.fd = cfd; ev.events = EPOLLIN | EPOLLET; //上树 epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;ev); } else if( evs[i].events &amp; EPOLLIN )//一定是cfd变化,在确认一下是不是cfd的读事件变化了 { while(1) { // cfd的读事件变化 读取客户端发过来的消息 char buf[4]=&quot;&quot;; int count = Read(fd, buf,sizeof(buf));//阻塞 //如果read读的缓冲区没有数据,read的返回值是-1 errno的值会被设置成EAGAIN if(count &lt; 0) { if(errno == EAGAIN) { break; } //出错 下树 perror(&quot;&quot;); close(fd); epoll_ctl(epfd,EPOLL_CTL_DEL,fd,&amp;evs[i]); break; } else if(count == 0) { //客户端关闭, 下树 printf(&quot;client close\\n&quot;); close(fd); epoll_ctl(epfd,EPOLL_CTL_DEL,fd,&amp;evs[i]); break; } else { write(STDOUT_FILENO,buf,count); Write(fd,buf,count); } } } } } } return 0;}","categories":[],"tags":[]},{"title":"My_hexo_blog","slug":"My-hexo-blog","date":"2019-06-19T02:58:41.000Z","updated":"2019-06-19T03:10:52.089Z","comments":true,"path":"2019/06/19/My-hexo-blog/","link":"","permalink":"http://yoursite.com/2019/06/19/My-hexo-blog/","excerpt":"","text":"##第一篇 —内容— ##第二篇 —内容— ##第三篇 —内容—","categories":[],"tags":[]}]}